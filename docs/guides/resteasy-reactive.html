<!DOCTYPE html>
<html>





<head>
  <title>RESTEasy Reactive を使用した REST サービスの作成 - Quarkus</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Security-Policy" content="default-src https://dpm.demdex.net; script-src 'self' 'unsafe-eval' 'sha256-ANpuoVzuSex6VhqpYgsG25OHWVA1I+F6aGU04LoI+5s=' 'sha256-ipy9P/3rZZW06mTLAR0EnXvxSNcnfSDPLDuh3kzbB1w=' js.bizographics.com https://www.redhat.com https://static.redhat.com assets.adobedtm.com jsonip.com https://ajax.googleapis.com https://www.googletagmanager.com https://www.google-analytics.com https://use.fontawesome.com https://app.mailjet.com http://www.youtube.com http://www.googleadservices.com https://googleads.g.doubleclick.net https://dpm.demdex.net https://giscus.app; style-src 'self' https://fonts.googleapis.com https://use.fontawesome.com; img-src 'self' *; media-src 'self'; frame-src https://www.googletagmanager.com https://www.youtube.com https://embed.restream.io https://app.mailjet.com https://giscus.app; base-uri 'none'; object-src 'none'; form-action 'none'; font-src 'self' https://use.fontawesome.com https://fonts.gstatic.com;" />
  <script id="adobe_dtm" src="https://www.redhat.com/dtm.js" type="text/javascript"></script>
  <script src="/assets/javascript/highlight.pack.js" type="text/javascript"></script>
  <META HTTP-EQUIV='X-XSS-Protection' CONTENT="1; mode=block">
  <META HTTP-EQUIV='X-Content-Type-Options' CONTENT="nosniff">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Quarkus: Supersonic Subatomic Java">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@QuarkusIO"> 
  <meta name="twitter:creator" content="@QuarkusIO">
  <meta property="og:url" content="https://quarkus.io/guides/resteasy-reactive" />
  <meta property="og:title" content="RESTEasy Reactive を使用した REST サービスの作成" />
  <meta property="og:description" content="Quarkus: Supersonic Subatomic Java" />
  <meta property="og:image" content="https://quarkus.io/assets/images/quarkus_card.png" />
  
  <link rel="canonical" href="https://quarkus.io/guides/resteasy-reactive">
  <link rel="shortcut icon" type="image/png" href="/favicon.ico" >
  <link rel="stylesheet" href="/guides/stylesheet/config.css" />
  <link rel="stylesheet" href="/assets/css/main.css?2021-07-29" />
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous">
  <link rel="alternate" type="application/rss+xml"  href="/feed.xml" title="Quarkus">
  <script src="/assets/javascript/goan.js" type="text/javascript"></script>
  <script src="/assets/javascript/hl.js" type="text/javascript"></script>
  
  
  
  
  <link rel="alternate" hreflang="en" href="https://quarkus.io/guides/resteasy-reactive" />
  
  <link rel="alternate" hreflang="es" href="https://es.quarkus.io/guides/resteasy-reactive" />
  
  <link rel="alternate" hreflang="zh" href="https://cn.quarkus.io/guides/resteasy-reactive" />
  
  <link rel="alternate" hreflang="ja" href="https://ja.quarkus.io/guides/resteasy-reactive" />
  
  <link rel="alternate" hreflang="x-default" href="https://quarkus.io/" />
</head>

<body class="guides">
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJWS5L"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

  

<div class="grid-wrapper communitysite">
  <div class="grid__item width-12-12">The <a href="https://quarkus.io">English version of quarkus.io</a> is the official project site. Translated sites are community supported on a best-effort basis.</div>
</div>


  <div class="nav-wrapper">
  <div class="grid-wrapper">
    <div class="width-12-12">
      <input type="checkbox" id="checkbox" />
      <nav id="main-nav" class="main-nav">
  <div class="container">
    <div class="logo-wrapper">
        <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_600px_reverse.png" class="project-logo" title="Quarkus"></a>
    </div>
    <label class="nav-toggle" for="checkbox"> <i class="fa fa-bars"></i>
</label>
    <ul id="menu" class="menu">
      <li class="dropdown">
        <span href="/about/">Quarkusとは <i class="fas
fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="/about" class="">QUARKUSとは何か?</a></li>
          <li><a href="/container-first" class="">コンテナ・ファースト</a></li>
          <li><a href="/continuum" class="">リアクティブ</a></li>
          <li><a href="/developer-joy" class="">開発者満足</a></li>
          <li><a href="/kubernetes-native" class="">KUBERNETES NATIVE</a></li>
          <li><a href="/standards" class="">標準</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <span href="/learn/">学ぶ<i class="fas
fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="/get-started" class="">入門</a></li>
          <li><a href="/guides" class="active">ガイド</a></li>
          <li><a href="/qtips" class="">"Q" Tipsビデオ</a></li>          
          <li><a href="/books" class="">書籍</a></li>
          </ul>
      </li>
      <li class="dropdown">
        <span href="/community/">コミュニティ <i class="fas
fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="/support/" class="">サポート</a></li>
          <li><a href="/blog" class="">ブログ</a></li>
          <li><a href="/discussion" class="">ディスカッション</a></li>
          <li><a href="/insights" class="">ポッドキャスト</a></li>
          <li><a href="/events" class="">イベント</a></li>
          <li><a href="/newsletter" class="">ニュースレター</a></li>
          <li><a href="/publications" class="">出版物</a></li>
          <li><a href="/awards" class="">受賞</a></li>
          </ul>
      </li>
      <li>
        <a href="https://code.quarkus.io" class="button-cta secondary
white">コーディングを開始</a>
      </li>
      <li class="dropdown">
        <span href="/language/"><div class="fas fa-globe langicon"></div><i class="fas fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="https://quarkus.io/guides/resteasy-reactive" >OFFICIAL (ENGLISH)</a></li>
          <li><a href="https://es.quarkus.io/guides/resteasy-reactive">ESPAÑOL</a></li>
          <li><a href="https://cn.quarkus.io/guides/resteasy-reactive">简体中文</a></li>
          <li><a href="https://ja.quarkus.io/guides/resteasy-reactive">日本語</a></li>
          </ul>
      </li>
    </ul>
  </div>
      </nav>
    </div>
  </div>
</div>

  <div class="content">
    



<div class="full-width-version-bg grey align-self">
  <div class="grid-wrapper">
    <div class="grid__item width-6-12">
      <p class="returnlink"><i class="fas fa-angle-left"></i><a href="/guides/">ガイド一覧に戻る</a></p>
    </div>
    <div class="grid__item width-6-12 align-self-center text-right hide-mobile">
      <label id="guide-version-label">ガイドのバージョンを選択</label>
      <select id="guide-version-dropdown">
        
      
        
        
        
        
          
        <option value="main" >Main - SNAPSHOT</option>
        
        
      
        
        
        
        
          
        <option value="latest" selected>2.12 - Latest</option>
        
        
      
        
        
        
        
          
        <option value="2.7" >2.7</option>
        
        
      
        
        
        
        
          
        <option value="2.2" >2.2</option>
        
        
      
        
        
        
        
          
        <option value="1.11" >1.11</option>
        
        
      
    
      </select>
    </div>
  </div>
</div>

<div class="grid-wrapper guide">
  <div class="grid__item width-12-12 width-12-12-mobile">
    <h1 class="text-caps">RESTEasy Reactive を使用した REST サービスの作成 </h1>
  </div>
  <div class="width-12-12">
    <div class="hide-mobile toc"><ul class="sectlevel1">
<li><a href="#resteasy-reactiveとは">RESTEasy Reactiveとは？</a></li>
<li><a href="#エンドポイントの作成">エンドポイントの作成</a>
<ul class="sectlevel2">
<li><a href="#はじめに">はじめに</a></li>
<li><a href="#用語解説">用語解説</a></li>
<li><a href="#エンドポイントの宣言uri-マッピング">エンドポイントの宣言:URI マッピング</a></li>
<li><a href="#エンドポイントの宣言-http-メソッド">エンドポイントの宣言: HTTP メソッド</a></li>
<li><a href="#エンドポイントの宣言-表現コンテンツタイプ">エンドポイントの宣言: 表現/コンテンツタイプ</a></li>
<li><a href="#リクエストパラメーターへのアクセス">リクエストパラメーターへのアクセス</a></li>
<li><a href="#uri-パラメーターの宣言">URI パラメーターの宣言</a></li>
<li><a href="#リクエスト本文へのアクセス">リクエスト本文へのアクセス</a></li>
<li><a href="#multipart">マルチパートフォームデータの処理</a></li>
<li><a href="#レスポンス本文を返す">レスポンス本文を返す</a></li>
<li><a href="#他のレスポンスプロパティーの設定">他のレスポンスプロパティーの設定</a></li>
<li><a href="#非同期リアクティブサポート">非同期/リアクティブサポート</a></li>
<li><a href="#ストリーミングサポート">ストリーミングサポート</a></li>
<li><a href="#サーバー送信イベント-sse-のサポート">サーバー送信イベント (SSE) のサポート</a></li>
<li><a href="#http-キャッシング機能の制御">HTTP キャッシング機能の制御</a></li>
<li><a href="#コンテキストオブジェクトへのアクセス">コンテキストオブジェクトへのアクセス</a></li>
<li><a href="#json-シリアル化">JSON シリアル化</a></li>
<li><a href="#xml-シリアル化">XML シリアル化</a></li>
<li><a href="#web-リンクのサポート">Web リンクのサポート</a></li>
</ul>
</li>
<li><a href="#cors-フィルター">CORS フィルター</a></li>
<li><a href="#より高度な使用法">より高度な使用法</a>
<ul class="sectlevel2">
<li><a href="#実行モデルブロッキング非ブロッキング">実行モデル、ブロッキング、非ブロッキング</a></li>
<li><a href="#exception-mapping">例外のマッピング</a></li>
<li><a href="#リクエストまたはレスポンスフィルター">リクエストまたはレスポンスフィルター</a></li>
<li><a href="#リーダーとライター-マッピングエンティティーと-http-本文">リーダーとライター: マッピングエンティティーと HTTP 本文</a></li>
<li><a href="#リーダーおよびライターインターセプター">リーダーおよびライターインターセプター</a></li>
<li><a href="#パラメータマッピング">パラメータマッピング</a></li>
<li><a href="#前提条件">前提条件</a></li>
<li><a href="#ネゴシエーション">ネゴシエーション</a></li>
<li><a href="#http-圧縮">HTTP 圧縮</a></li>
</ul>
</li>
<li><a href="#ビルド時条件でjax-rsクラスを含める除外する">ビルド時条件でJAX-RSクラスを含める/除外する</a></li>
<li><a href="#resteasy-reactive-クライアント">RESTEasy Reactive クライアント</a></li>
</ul></div>
    <div>
      <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>このガイドでは、QuarkusでRESTEasy Reactiveを使用してRESTサービスを記述する方法を説明します。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>本書は、RESTEasy Reactiveのリファレンスガイドです。よりライトな紹介は、 <a href="rest-json.html">Writing JSON REST servicesのガイド</a> を参照してください。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="resteasy-reactiveとは"><a class="anchor" href="#resteasy-reactiveとは"></a>RESTEasy Reactiveとは？</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RESTEasy Reactive は共通の <a href="https://vertx.io/">Vert.x</a> レイヤーで動作するように一から書かれた新しい <a href="/specs/jaxrs/2.1/index.html">JAX-RS</a> の実装であり、完全にリアクティブです。また、Quarkus と非常に緊密に統合されており、結果として多くの作業をビルド時に移動させます。</p>
</div>
<div class="paragraph">
<p>JAX-RSの実装の代わりに使うことができるはずですが、それに加えて、ブロッキングエンドポイントとノンブロッキングエンドポイントの両方で優れたパフォーマンスを発揮し、JAX-RSが提供する機能に加えて多くの新機能を備えています。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="エンドポイントの作成"><a class="anchor" href="#エンドポイントの作成"></a>エンドポイントの作成</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="はじめに"><a class="anchor" href="#はじめに"></a>はじめに</h3>
<div class="paragraph">
<p>次のインポートをビルドファイルに追加します:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-resteasy-reactive&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">implementation("io.quarkus:quarkus-resteasy-reactive")</code></pre>
</div>
</div>
<div class="paragraph">
<p>これで、 <code>org.acme.rest.Endpoint</code> クラスで最初のエンドポイントを書くことができます:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("")
public class Endpoint {

    @GET
    public String hello() {
        return "Hello, World!";
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="用語解説"><a class="anchor" href="#用語解説"></a>用語解説</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">REST</dt>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REpresentational State Transfer</a></p>
</dd>
<dt class="hdlist1">エンドポイント</dt>
<dd>
<p>REST 呼び出しを提供するために呼び出される Java メソッド</p>
</dd>
<dt class="hdlist1">URL / URI (Uniform Resource Locator / Identifier)</dt>
<dd>
<p>REST リソースの場所を特定するために使用されます (<a href="https://tools.ietf.org/html/rfc7230#section-2.7">仕様</a>)</p>
</dd>
<dt class="hdlist1">リソース</dt>
<dd>
<p>ドメインオブジェクトを表します。これは、API が提供および変更するものです。JAX-RS ではエンティティーとも呼ばれます。</p>
</dd>
<dt class="hdlist1">表現</dt>
<dd>
<p>通信上でのリソースの表現方法は、Content typeによって異なります。</p>
</dd>
<dt class="hdlist1">Content type</dt>
<dd>
<p>text/plain や application/json などの特定の表現 (メディアタイプとも呼ばれます) を指定します</p>
</dd>
<dt class="hdlist1">HTTP</dt>
<dd>
<p>REST 呼び出しをルーティングするための基本的なワイヤープロトコル (<a href="https://tools.ietf.org/html/rfc7230">HTTP 仕様</a> を参照)</p>
</dd>
<dt class="hdlist1">HTTP リクエスト</dt>
<dd>
<p>HTTP メソッド、ターゲット URI、ヘッダー、およびオプションのメッセージ本文で設定される HTTP 呼び出しのリクエスト部分</p>
</dd>
<dt class="hdlist1">HTTP レスポンス</dt>
<dd>
<p>HTTP レスポンスステータス、ヘッダー、およびオプションのメッセージ本文で設定される HTTP 呼び出しのレスポンス部分</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="エンドポイントの宣言uri-マッピング"><a class="anchor" href="#エンドポイントの宣言uri-マッピング"></a>エンドポイントの宣言:URI マッピング</h3>
<div class="paragraph">
<p><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/Path.html"><code>@Path</code></a> アノテーションを持つクラスは、HTTP メソッドアノテーション (下記参照) を持っていれば、そのメソッドを REST エンドポイントとして公開することができます。</p>
</div>
<div class="paragraph">
<p><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/Path.html"><code>@Path</code></a> アノテーションは、これらのメソッドが公開される URI の接頭辞を定義します。これは空であるか、あるいは <code>rest</code> や <code>rest/V1</code> のような接頭辞を含むことができます。</p>
</div>
<div class="paragraph">
<p>公開された各エンドポイントメソッドは、別の <a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/Path.html"><code>@Path</code></a> アノテーションを持つことができ、それを含むクラスアノテーションを追加されます。例えば、これは <code>rest/hello</code> というエンドポイントを定義しています:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("rest")
public class Endpoint {

    @Path("hello")
    @GET
    public String hello() {
        return "Hello, World!";
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>URI マッピングの詳細は、<a href="#uri-parameters">URI parameters</a> を参照してください。</p>
</div>
<div class="paragraph">
<p>以下に示すように、<code>@ApplicationPath</code> アノテーションを使用して、すべての REST エンドポイントのルートパスを設定できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/api")
public static class MyApplication extends Application {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will cause all rest endpoints to be resolve relative to <code>/api</code>, so the endpoint above with <code>@Path("rest")</code> would be accessible at <code>/api/rest/</code>. You can also set the <code>quarkus.resteasy-reactive.path</code> build time property to set the root path if you don&#8217;t want to use an annotation.</p>
</div>
</div>
<div class="sect2">
<h3 id="エンドポイントの宣言-http-メソッド"><a class="anchor" href="#エンドポイントの宣言-http-メソッド"></a>エンドポイントの宣言: HTTP メソッド</h3>
<div class="paragraph">
<p>各エンドポイントメソッドには、次のいずれかのアノテーションを付ける必要があります。これにより、どの HTTP メソッドがそのメソッドにマップされるかが定義されます。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. テーブル HTTP メソッドのアノテーション</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">アノテーション</th>
<th class="tableblock halign-left valign-top">使用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/GET.html"><code>@GET</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">リソース表現を取得します。状態を変更しないでください。<a href="https://tools.ietf.org/html/rfc7231#section-4.2.2">冪等</a> (<a href="https://tools.ietf.org/html/rfc7231#section-4.3.1">HTTP docs</a>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/HEAD.html"><code>@HEAD</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">本文のない <code>GET</code> と同様に、リソースに関するメタデータを取得します (<a href="https://tools.ietf.org/html/rfc7231#section-4.3.2">HTTP docs</a>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/POST.html"><code>@POST</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">リソースを作成し、そのリソースへのリンクを取得します (<a href="https://tools.ietf.org/html/rfc7231#section-4.3.3">HTTP docs</a>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/PUT.html"><code>@PUT</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">リソースを置き換えるか作成します。<a href="https://tools.ietf.org/html/rfc7231#section-4.2.2">冪等</a> (<a href="https://tools.ietf.org/html/rfc7231#section-4.3.4">HTTP docs</a>) であるべきです。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/DELETE.html"><code>@DELETE</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">既存のリソースを削除します。<a href="https://tools.ietf.org/html/rfc7231#section-4.2.2">冪等</a>  (<a href="https://tools.ietf.org/html/rfc7231#section-4.3.5">HTTP docs</a>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/OPTIONS.html"><code>@OPTIONS</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">リソースに関する情報を取得します。<a href="https://tools.ietf.org/html/rfc7231#section-4.2.2">冪等</a> (<a href="https://tools.ietf.org/html/rfc7231#section-4.3.7">HTTP docs</a>) です。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/PATCH.html"><code>@PATCH</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">リソースを更新するか、作成します。<a href="https://tools.ietf.org/html/rfc7231#section-4.2.2">冪等</a> (<a href="https://tools.ietf.org/html/rfc5789#section-2">HTTP docs</a>) ではありません。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/HttpMethod.html"><code>@HttpMethod</code></a> アノテーションを付与したアノテーションを宣言することにより、他の HTTP メソッドを宣言することもできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

import javax.ws.rs.HttpMethod;
import javax.ws.rs.Path;

@Retention(RetentionPolicy.RUNTIME)
@HttpMethod("CHEESE")
@interface CHEESE {
}

@Path("")
public class Endpoint {

    @CHEESE
    public String hello() {
        return "Hello, Cheese World!";
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="エンドポイントの宣言-表現コンテンツタイプ"><a class="anchor" href="#エンドポイントの宣言-表現コンテンツタイプ"></a>エンドポイントの宣言: 表現/コンテンツタイプ</h3>
<div class="paragraph">
<p>各エンドポイントメソッドは、特定のリソース表現を消費したり生成したりすることがあり、それは HTTP <a href="https://tools.ietf.org/html/rfc7231#section-3.1.1.5"><code>Content-Type</code></a> header で示され、その中に次のような <a href="https://tools.ietf.org/html/rfc7231#section-3.1.1.1">MIME (Media Type)</a> 値が含まれています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String</code> を返すエンドポイントのデフォルトである <code>text/plain</code>。</p>
</li>
<li>
<p>HTML の <code>text/html</code> (such as with <a href="qute">Qute templating</a>)</p>
</li>
<li>
<p><a href="#json">JSON REST endpoint</a> の <code>application/json</code></p>
</li>
<li>
<p>任意のテキストメディアタイプのサブタイプワイルドカードである <code>text/*</code></p>
</li>
<li>
<p><code>*/*</code> は、あらゆるメディアタイプのワイルドカードです</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/Produces.html"><code>@Produces</code></a> または <a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/Consumes.html"><code>@Consumes</code></a> アノテーションで、エンドポイントクラスをアノテーションできます。この場合、エンドポイントが HTTP リクエストボディとして受け入れ、HTTP レスポンスボディとして生成できるメディアタイプを一つまたは複数指定することが可能です。これらのクラスアノテーションは、各メソッドに適用されます。</p>
</div>
<div class="paragraph">
<p>どのメソッドも <a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/Produces.html"><code>@Produces</code></a> または <a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/Consumes.html"><code>@Consumes</code></a> アノテーションを付けることができ、その場合は最終的にどのクラスアノテーションもオーバーライドされることになります。</p>
</div>
<div class="paragraph">
<p><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/core/MediaType.html"><code>MediaType</code></a> クラスには、特定の事前定義されたメディアタイプを指すために使用できる多くの定数があります。</p>
</div>
<div class="paragraph">
<p>詳細は、<a href="#negotiation">[negotiation]</a> を参照してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="リクエストパラメーターへのアクセス"><a class="anchor" href="#リクエストパラメーターへのアクセス"></a>リクエストパラメーターへのアクセス</h3>
<div id="request-parameters" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
パラメーター名の情報を生成するために、<code>-parameters</code> (javac) または <code>&lt;parameters&gt;</code> または <code>&lt;maven.compiler.parameters&gt;</code> (<a href="https://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#parameters">Maven</a>) を使ってコンパイラーを設定することを忘れないでください。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>次の HTTP リクエスト要素は、エンドポイントメソッドによって取得される可能性があります。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. テーブル HTTP リクエストパラメーターアノテーション</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">HTTP 要素</th>
<th class="tableblock halign-left valign-top">アノテーション</th>
<th class="tableblock halign-left valign-top">使用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="path-parameter"></a>Path パラメーター</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/RestPath.html"><code>@RestPath</code></a> (または、なにもない)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">URI template parameter (simplified version of the <a href="https://tools.ietf.org/html/rfc6570">URI Template specification</a>),
see <a href="#uri-parameters">URI parameters</a> for more information.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">クエリーパラメーター</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/RestQuery.html"><code>@RestQuery</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The value of a <a href="https://tools.ietf.org/html/rfc3986#section-3.4">URI query parameter</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ヘッダ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/RestHeader.html"><code>@RestHeader</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://tools.ietf.org/html/rfc7230#section-3.2">HTTP header</a> の値</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cookie</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/RestCookie.html"><code>@RestCookie</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://tools.ietf.org/html/rfc6265#section-4.2">HTTP cookie</a> の値</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">フォームパラメーター</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/RestForm.html"><code>@RestForm</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST">HTTP URL-encoded FORM</a> の値</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">マトリックスパラメーター</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/RestMatrix.html"><code>@RestMatrix</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://tools.ietf.org/html/rfc3986#section-3.3">URI path segment parameter</a> の値</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>これらのアノテーションごとに、参照する要素の名前を指定できます。指定しない場合は、アノテーションが付けられたメソッドパラメーターの名前が使用されます。</p>
</div>
<div class="paragraph">
<p>クライアントが次の HTTP 呼び出しを行った場合:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-http hljs" data-lang="http">POST /cheeses;variant=goat/tomme?age=matured HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Cookie: level=hardcore
X-Cheese-Secret-Handshake: fist-bump

smell=strong</code></pre>
</div>
</div>
<div class="paragraph">
<p>次に、このエンドポイントメソッドを使用してさまざまなパラメーターをすべて取得できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import javax.ws.rs.POST;
import javax.ws.rs.Path;

import org.jboss.resteasy.reactive.RestCookie;
import org.jboss.resteasy.reactive.RestForm;
import org.jboss.resteasy.reactive.RestHeader;
import org.jboss.resteasy.reactive.RestMatrix;
import org.jboss.resteasy.reactive.RestPath;
import org.jboss.resteasy.reactive.RestQuery;

@Path("/cheeses/{type}")
public class Endpoint {

    @POST
    public String allParams(@RestPath String type,
                            @RestMatrix String variant,
                            @RestQuery String age,
                            @RestCookie String level,
                            @RestHeader("X-Cheese-Secret-Handshake")
                            String secretHandshake,
                            @RestForm String smell) {
        return type + "/" + variant + "/" + age + "/" + level + "/" + secretHandshake + "/" + smell;
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/RestPath.html"><code>@RestPath</code></a> アノテーションはオプションです。名前が既存の URI テンプレート変数に一致する任意のパラメーターは、自動的に <a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/RestPath.html"><code>@RestPath</code></a> を持っていると想定されます。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>JAX-RS のアノテーションも使用できます。<a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/PathParam.html"><code>@PathParam</code></a>、<a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/QueryParam.html"><code>@QueryParam</code></a>、<a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/HeaderParam.html"><code>@HeaderParam</code></a>、<a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/CookieParam.html"><code>@CookieParam</code></a>、<a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/FormParam.html"><code>@FormParam</code></a> または <a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/MatrixParam.html"><code>@MatrixParam</code></a>。しかし、パラメーター名の指定が必要です。</p>
</div>
<div class="paragraph">
<p>より詳細なユースケースは、 <a href="#parameter-mapping">[parameter-mapping]</a> を参照してください。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When an exception occurs in RESTEasy Reactive request parameter handling code, the exception is not printed by default to the log (for security reasons). This can sometimes make it hard to understand why certain HTTP status codes are returned (as the JAX-RS mandates the use of non-intuitive error codes in various cases). In such cases, users are encouraged to set the logging level for the <code>org.jboss.resteasy.reactive.server.handlers.ParameterHandler</code> category to <code>DEBUG</code> like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.log.category."org.jboss.resteasy.reactive.server.handlers.ParameterHandler".level=DEBUG</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="uri-パラメーターの宣言"><a class="anchor" href="#uri-パラメーターの宣言"></a>URI パラメーターの宣言</h3>
<div id="uri-parameters" class="paragraph">
<p>URI パラメーターを宣言し、パスで正規表現を使用できるため、たとえば、次のエンドポイントは <code>/hello/stef/23</code> と <code>/hello</code> のリクエストを処理しますが、<code>/hello/stef/0x23</code> は処理しません。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("hello")
public class Endpoint {

    @Path("{name}/{age:\\d+}")
    @GET
    public String personalisedHello(String name, int age) {
        return "Hello " + name + " is your age really " + age + "?";
    }

    @GET
    public String genericHello() {
        return "Hello stranger";
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="リクエスト本文へのアクセス"><a class="anchor" href="#リクエスト本文へのアクセス"></a>リクエスト本文へのアクセス</h3>
<div class="paragraph">
<p>アノテーションのないメソッドパラメーターは、HTTP 表現からパラメーターの Java タイプにマッピングされた後、それが <a href="#path-parameter">URI template parameter</a> または <a href="#context-objects">context object</a> でない限り、メソッド本文の脚注を受け取ります。</p>
</div>
<div class="paragraph">
<p>次のパラメータータイプは、そのままでサポートされます。</p>
</div>
<table id="resource-types" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. テーブルリクエスト本文のパラメータータイプ</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">タイプe</th>
<th class="tableblock halign-left valign-top">使用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html"><code>File</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一時ファイル内のリクエスト本文全体</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>byte[]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">デコードされていないリクエスト本文全体</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>char[]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">デコードされたリクエスト本文全体</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html"><code>String</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">デコードされたリクエスト本文全体</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InputStream.html"><code>InputStream</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ブロッキングストリームのリクエスト本文</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Reader.html"><code>Reader</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ブロッキングストリームのリクエスト本文</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">すべての Java プリミティブとそのラッパークラス</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java プリミティブタイプ</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html"><code>BigDecimal</code></a>、<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigInteger.html"><code>BigInteger</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大きな整数と小数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.json/javax.json-api/1.1.4/javax/json/JsonArray.html"><code>JsonArray</code></a>, <a href="https://javadoc.io/doc/javax.json/javax.json-api/1.1.4/javax/json/JsonObject.html"><code>JsonObject</code></a>,
<a href="https://javadoc.io/doc/javax.json/javax.json-api/1.1.4/javax/json/JsonStructure.html"><code>JsonStructure</code></a>, <a href="https://javadoc.io/doc/javax.json/javax.json-api/1.1.4/javax/json/JsonValue.html"><code>JsonValue</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON 値のタイプ</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/io.vertx/vertx-core/latest/index.htmlio/vertx/core/buffer/Buffer.html"><code>Buffer</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Vert.x Buffer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">その他のタイプ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#json">mapped from JSON to that type</a> になります</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
さらに<a href="#readers-writers">body parameter types</a> のサポートを追加することができます。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="multipart"><a class="anchor" href="#multipart"></a>マルチパートフォームデータの処理</h3>
<div class="paragraph">
<p>RESTEasy Reactive は、コンテンツタイプとして <code>multipart/form-data</code> を持つ HTTP リクエストを処理するために、 <a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/MultipartForm.html"><code>@MultipartForm</code></a> アノテーションを導入しています。その使用例を見てみましょう。</p>
</div>
<div class="paragraph">
<p>ファイルのアップロードを含む HTTP リクエストと、文字列の説明を含むフォーム値を処理する必要があると仮定すると、次のようにこの情報を保持する POJO を記述できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import javax.ws.rs.core.MediaType;

import org.jboss.resteasy.reactive.PartType;
import org.jboss.resteasy.reactive.RestForm;
import org.jboss.resteasy.reactive.multipart.FileUpload;

public class FormData {

    @RestForm
    @PartType(MediaType.TEXT_PLAIN)
    public String description;

    @RestForm("image")
    public FileUpload file;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>name</code> フィールドには、HTTP リクエストの <code>description</code> という部分に含まれるデータが入ります (<a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/RestForm.html"><code>@RestForm</code></a> は値を定義しないため、フィールド名が使用されます)。一方 <code>file</code> フィールドには、HTTP リクエストの <code>image</code> 部分にアップロードしたファイルに関するデータが格納されます。</p>
</div>
<div class="paragraph">
<p>The size of every part in a multipart request must conform to the value of <code>quarkus.http.limits.max-form-attribute-size</code>, for which the default is 2048 bytes. Any request with a part size exceeding this configuration will result in HTTP status code 413.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/multipart/FileUpload.html"><code>FileUpload</code></a> はアップロードされたファイルの様々なメタデータにアクセスすることができます。しかし、アップロードされたファイルへの処理が必要なだけなら、<code>java.nio.file.Path</code> や <code>java.io.File</code> を使用することができます。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
フォーム名を指定せずにアップロードされたすべてのファイルにアクセスする必要がある場合、RESTEasy Reactive では <code>@RestForm List&lt;FileUpload&gt;</code> を使用できます。ここで、<a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/RestForm.html"><code>@RestForm</code></a> アノテーションにnameを設定することは重要では<strong>ありません</strong>。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/PartType.html"><code>@PartType</code></a> は、リクエストの対応する部分を希望の Java タイプにデシリアライズする際に使用されます。たとえば、対応する本文部分が JSON であり、POJO に変換する必要がある場合に非常に便利です。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>この POJO は、次のような Resource メソッドで使用できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import javax.ws.rs.Consumes;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

import org.jboss.resteasy.reactive.MultipartForm;

@Path("multipart")
public class Endpoint {

    @POST
    @Produces(MediaType.APPLICATION_JSON)
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    @Path("form")
    public String form(@MultipartForm FormData formData) {
        // return something
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/MultipartForm.html"><code>@MultipartForm</code></a> をメソッドパラメーターとして使用すると、RESTEasy Reactive はマルチパートフォームリクエストとして処理することができるようになります。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
RESTEasy Reactive は <code>@Consumes(MediaType.MULTIPART_FORM_DATA)</code> の使用からこの情報を推測できるので、<code>@MultipartForm</code> の使用は実際には不要です。
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
When handling file uploads, it is very important to move the file to permanent storage (like a database, a dedicated file system or a cloud storage) in your code that handles the POJO. Otherwise, the file will no longer be accessible when the request terminates. Moreover, if <code>quarkus.http.body.delete-uploaded-files-on-end</code> is set to true, Quarkus will delete the uploaded file when the HTTP response is sent. If the setting is disabled, the file will reside on the file system of the server (in the directory defined by the <code>quarkus.http.body.uploads-directory</code> configuration option), but as the uploaded files are saved with a UUID file name and no additional metadata is saved, these files are essentially a random dump of files.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>同様に、RESTEasy Reactive は、ユーザーがサーバーからファイルをダウンロードできるようにするための Multipart Form データを生成することができます。例えば、公開したい情報を保持する POJO を、次のように書くことができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import javax.ws.rs.core.MediaType;

import org.jboss.resteasy.reactive.PartType;
import org.jboss.resteasy.reactive.RestForm;

public class DownloadFormData {

    @RestForm
    String name;

    @RestForm
    @PartType(MediaType.APPLICATION_OCTET_STREAM)
    File file;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>そして、次のようなリソースを介してこの POJO を公開します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("multipart")
public class Endpoint {

    @GET
    @Produces(MediaType.MULTIPART_FORM_DATA)
    @Path("file")
    public DownloadFormData getFile() {
        // return something
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
当面、マルチパートデータを返すことはエンドポイントをブロックすることに限定されます。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="handling-malformed-input"><a class="anchor" href="#handling-malformed-input"></a>Handling malformed input</h4>
<div class="paragraph">
<p>As part of reading the multipart body, RESTEasy Reactive invokes the proper MessageBodyReader<a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/ext/MessageBodyReader.html"><code>MessageBodyReader</code></a> for each part of the request. If an <code>IOException</code> occurs for one of these parts (for example if Jackson was unable to deserialize a JSON part), then a <code>org.jboss.resteasy.reactive.server.multipart.MultipartPartReadingException</code> is thrown. If this exception is not handled by the application as mentioned in <a href="#exception-mapping">例外のマッピング</a>, an HTTP 400 response is returned by default.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="レスポンス本文を返す"><a class="anchor" href="#レスポンス本文を返す"></a>レスポンス本文を返す</h3>
<div class="paragraph">
<p>HTTP レスポンスを返すには、単にメソッドから必要なリソースを返します。メソッドの戻り値の型とオプションのコンテントタイプをもとに、HTTP レスポンスへのシリアライズ方法を決定します (より詳細な情報については <a href="#negotiation">[negotiation]</a> を参照ください)。</p>
</div>
<div class="paragraph">
<p><a href="#resource-types">HTTP レスポンス</a> から読み取れる、あらかじめ定義された任意の型を返すことができ、それ以外の型は<a href="#json">型からJSON</a> にマッピングされます。</p>
</div>
<div class="paragraph">
<p>さらに、次の戻り値の型もサポートされています。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. 表 追加のレスポンスボディパラメータータイプ</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">タイプe</th>
<th class="tableblock halign-left valign-top">使用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/Path.html"><code>Path</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定されたパスで指定されたファイルの内容</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/PathPart.html"><code>PathPart</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定されたパスで指定されたファイルの部分的な内容</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/FilePart.html"><code>FilePart</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ファイルの部分的な内容</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/io.vertx/vertx-core/latest/index.html/io/vertx/core/file/AsyncFile.html"><code>AsyncFile</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Vert.x AsyncFile、完全または部分的</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>あるいは、 <a href="https://javadoc.io/doc/io.smallrye.reactive/mutiny/1.6.0/io/smallrye/mutiny/Uni.html"><code>Uni</code></a> 、<a href="https://javadoc.io/doc/io.smallrye.reactive/mutiny/1.6.0/io/smallrye/mutiny/Multi.html"><code>Multi</code></a> または <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html"><code>CompletionStage</code></a> など、前述の戻り値の型に解決して、<a href="#reactive">リアクティブ型</a> を返すことも可能です。</p>
</div>
</div>
<div class="sect2">
<h3 id="他のレスポンスプロパティーの設定"><a class="anchor" href="#他のレスポンスプロパティーの設定"></a>他のレスポンスプロパティーの設定</h3>
<div class="sect3">
<h4 id="手動でレスポンスを設定する"><a class="anchor" href="#手動でレスポンスを設定する"></a>手動でレスポンスを設定する</h4>
<div class="paragraph">
<p>ステータスコードやヘッダーなど、本文だけでなく HTTP レスポンスに多くのプロパティーを設定する必要がある場合は、リソースメソッドからメソッドに <code>org.jboss.resteasy.reactive.RestResponse</code> を返すようにすることができます。この例は次のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import java.time.Duration;
import java.time.Instant;
import java.util.Date;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.NewCookie;

import org.jboss.resteasy.reactive.RestResponse;
import org.jboss.resteasy.reactive.RestResponse.ResponseBuilder;

@Path("")
public class Endpoint {

    @GET
    public RestResponse&lt;String&gt; hello() {
        // HTTP OK status with text/plain content type
        return ResponseBuilder.ok("Hello, World!", MediaType.TEXT_PLAIN_TYPE)
         // set a response header
         .header("X-Cheese", "Camembert")
         // set the Expires response header to two days from now
         .expires(Date.from(Instant.now().plus(Duration.ofDays(2))))
         // send a new cookie
         .cookie(new NewCookie("Flavour", "chocolate"))
         // end of builder API
         .build();
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
また、JAX-RS タイプの <a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/core/Response.html"><code>レスポンス</code></a> を使用することもできますが、エンティティーに強く型付けされるわけではありません。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="アノテーションの使用"><a class="anchor" href="#アノテーションの使用"></a>アノテーションの使用</h4>
<div class="paragraph">
<p>または、静的な値でステータスコードや HTTP ヘッダーのみを設定する必要がある場合は、それぞれ <code>@org.jboss.resteasy.reactive.ResponseStatus</code> および/または <code>ResponseHeader</code> を使用できます。この例は次のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import org.jboss.resteasy.reactive.Header;
import org.jboss.resteasy.reactive.ResponseHeaders;
import org.jboss.resteasy.reactive.ResponseStatus;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("")
public class Endpoint {

    @ResponseStatus(201)
    @ResponseHeader(name = "X-Cheese", value = "Camembert")
    @GET
    public String hello() {
        return "Hello, World!";
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="非同期リアクティブサポート"><a class="anchor" href="#非同期リアクティブサポート"></a>非同期/リアクティブサポート</h3>
<div id="reactive" class="paragraph">
<p>エンドポイントメソッドがレスポンスする前に非同期またはリアクティブタスクを実行する必要がある場合は、メソッドを宣言して( <a href="https://smallrye.io/smallrye-mutiny/">Mutiny</a> の) <a href="https://javadoc.io/doc/io.smallrye.reactive/mutiny/1.6.0/io/smallrye/mutiny/Uni.html"><code>Uni</code></a> 型を返すことができます 。この場合、現在の HTTP リクエストはメソッドの後で、返された<a href="https://javadoc.io/doc/io.smallrye.reactive/mutiny/1.6.0/io/smallrye/mutiny/Uni.html"><code>Uni</code></a> インスタンスが値に解決され、前述のルールに従って正確にレスポンスにマッピングされるまで自動的に一時停止されます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

import io.smallrye.mutiny.Uni;

@Path("escoffier")
public class Endpoint {

    @GET
    public Uni&lt;Book&gt; culinaryGuide() {
        return Book.findByIsbn("978-2081229297");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これにより、book がデータベースから取得されている間、イベントループスレッドをブロックせず、book がクライアントに送信できるようになるまで Quarkus がより多くのリクエストに対応し、このリクエストを終了させることができます。詳しくは、<a href="#execution-model">実行モデルドキュメント</a> を参照してください。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html"><code>CompletionStage</code></a> 戻り値の型もサポートされています。</p>
</div>
</div>
<div class="sect2">
<h3 id="ストリーミングサポート"><a class="anchor" href="#ストリーミングサポート"></a>ストリーミングサポート</h3>
<div class="paragraph">
<p>レスポンスを要素ごとにストリーミングする場合は、エンドポイントメソッドに( <a href="https://smallrye.io/smallrye-mutiny/">Mutiny</a> の) <a href="https://javadoc.io/doc/io.smallrye.reactive/mutiny/1.6.0/io/smallrye/mutiny/Multi.html"><code>Multi</code></a> 型を返すようにすることができます。これは、テキストまたはバイナリーデータのストリーミングに特に役立ちます。</p>
</div>
<div class="paragraph">
<p>この例では、 <a href="https://github.com/quarkiverse/quarkus-reactive-messaging-http">Reactive Messaging HTTP</a> を使用して、テキストデータをストリーミングする方法を示しています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;

import org.eclipse.microprofile.reactive.messaging.Channel;

import io.smallrye.mutiny.Multi;

@Path("logs")
public class Endpoint {

    @Inject
    @Channel("log-out")
    Multi&lt;String&gt; logs;

    @GET
    public Multi&lt;String&gt; streamLogs() {
        return logs;
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
レスポンスフィルターは、ストリーミングされたレスポンスでは呼び出されません。これは、ヘッダーまたは HTTP ステータスコードを設定できるという誤った印象を与えるためです。これは、最初のレスポンスの後では当てはまりません。レスポンスの一部がすでに書き込まれている可能性があるため、例外マッパーも呼び出されません。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="サーバー送信イベント-sse-のサポート"><a class="anchor" href="#サーバー送信イベント-sse-のサポート"></a>サーバー送信イベント (SSE) のサポート</h3>
<div class="paragraph">
<p>レスポンスで JSON オブジェクトをストリーミングする場合は、エンドポイントメソッドに <a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/Produces.html"><code>@Produces(MediaType.SERVER_SENT_EVENTS)</code></a> で注釈を付けるだけで、 <a href="https://html.spec.whatwg.org/multipage/server-sent-events.html">Server-Sent Events</a>を使用できます。そして指定した場合、 <code>@RestStreamElementType (MediaType.APPLICATION_JSON)</code> を使用し各要素は <a href="#json">JSONにシリアライズ</a> されるべきです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

import org.jboss.resteasy.reactive.RestStreamElementType;

import io.smallrye.mutiny.Multi;
import io.smallrye.mutiny.Uni;

import io.smallrye.reactive.messaging.annotations.Channel;

@Path("escoffier")
public class Endpoint {

    // Inject our Book channel
    @Inject
    @Channel("book-out")
    Multi&lt;Book&gt; books;

    @GET
    // Send the stream over SSE
    @Produces(MediaType.SERVER_SENT_EVENTS)
    // Each element will be sent as JSON
    @RestStreamElementType(MediaType.APPLICATION_JSON)
    public Multi&lt;Book&gt; stream() {
        return books;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="http-キャッシング機能の制御"><a class="anchor" href="#http-キャッシング機能の制御"></a>HTTP キャッシング機能の制御</h3>
<div class="paragraph">
<p>RESTEasy Reactive は、HTTP キャッシングセマンティックスの処理、つまり 'Cache-Control' HTTP ヘッダーの設定を容易にするために、<a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/Cache.html"><code>@Cache</code></a> と <a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/NoCache.html"><code>@NoCache</code></a> というアノテーションを提供します。</p>
</div>
<div class="paragraph">
<p>これらのアノテーションはリソースメソッドまたはリソースクラス (この場合、同じアノテーションを <strong>含まない</strong> クラスのすべてのリソースメソッドに適用されます) に配置することができ、ユーザーがドメインオブジェクトを返すことができ、明示的に <code>Cache-Control</code> HTTP ヘッダーを構築することに対処する必要はありません。</p>
</div>
<div class="paragraph">
<p><a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/Cache.html"><code>@Cache</code></a> が複雑な <code>Cache-Control</code> ヘッダーを構築するのに対し、<a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/NoCache.html"><code>@NoCache</code></a> は何もキャッシュさせたくない、つまり <code>Cache-Control: nocache</code> というシンプルな表記法になっています。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>Cache-Control</code> ヘッダーの詳細は、 <a href="https://datatracker.ietf.org/doc/html/rfc7234">RFC 7234</a> を参照してください
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="コンテキストオブジェクトへのアクセス"><a class="anchor" href="#コンテキストオブジェクトへのアクセス"></a>コンテキストオブジェクトへのアクセス</h3>
<div id="context-objects" class="paragraph">
<p>エンドポイントメソッドが次のタイプのパラメーターを受け取る場合、フレームワークが提供するコンテキストオブジェクトは多数あります。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. テーブルコンテキストオブジェクト</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">タイプe</th>
<th class="tableblock halign-left valign-top">使用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/core/HttpHeaders.html"><code>HttpHeaders</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">すべてのリクエストヘッダー</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/container/ResourceInfo.html"><code>ResourceInfo</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">現在のエンドポイントメソッドとクラスに関する情報 (リフレクションが必要)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/core/SecurityContext.html"><code>SecurityContext</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">現在のユーザーとロールへのアクセス</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive/2.12.1.Final/org/jboss/resteasy/reactive/server/SimpleResourceInfo.html"><code>SimpleResourceInfo</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">現在のエンドポイントメソッドとクラスに関する情報 (反映は不要)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/core/UriInfo.html"><code>UriInfo</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">現在のエンドポイントとアプリケーション URI に関する情報を提供します</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/core/Application.html"><code>Application</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">詳細: 現在の JAX-RS アプリケーションクラス</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/core/Configuration.html"><code>Configuration</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">詳細: デプロイされた JAX-RS アプリケーションに関する設定</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/ext/Providers.html"><code>Providers</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">詳細: JAX-RS プロバイダーへのランタイムアクセス</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/core/Request.html"><code>Request</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">詳細: 現在の HTTP メソッドへのアクセスと <a href="#preconditions">条件</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/core/ResourceContext.html"><code>ResourceContext</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">詳細: エンドポイントのインスタンスへのアクセス</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive/2.12.1.Final/org/jboss/resteasy/reactive/server/spi/ServerRequestContext.html"><code>ServerRequestContext</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">詳細:RESTEasy 現在の要求/レスポンスへのリアクティブアクセス</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/sse/Sse.html"><code>Sse</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">詳細: 複雑な SSE のユースケース</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/io.vertx/vertx-core/latest/index.html/io/vertx/core/http/HttpServerRequest.html"><code>HttpServerRequest</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">詳細: Vert.xHTTP リクエスト</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/io.vertx/vertx-core/latest/index.html/io/vertx/core/http/HttpServerResponse.html"><code>HttpServerResponse</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">詳細: Vert..x HTTP レスポンス</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>たとえば、現在ログインしているユーザーの名前を返す方法は次のとおりです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import java.security.Principal;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.SecurityContext;

@Path("user")
public class Endpoint {

    @GET
    public String userName(SecurityContext security) {
        Principal user = security.getUserPrincipal();
        return user != null ? user.getName() : "&lt;NOT LOGGED IN&gt;";
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>同じタイプのフィールドに <a href="https://javadoc.io/static/javax.inject/javax.inject/1/javax/inject/Inject.html"><code>@Inject</code></a> を使用して、これらのコンテキストオブジェクトを挿入することもできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import java.security.Principal;

import javax.inject.Inject;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.SecurityContext;

@Path("user")
public class Endpoint {

    @Inject
    SecurityContext security;

    @GET
    public String userName() {
        Principal user = security.getUserPrincipal();
        return user != null ? user.getName() : "&lt;NOT LOGGED IN&gt;";
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>または、エンドポイントコンストラクターでも:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import java.security.Principal;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.SecurityContext;

@Path("user")
public class Endpoint {

    SecurityContext security;

    Endpoint(SecurityContext security) {
        this.security = security;
    }

    @GET
    public String userName() {
        Principal user = security.getUserPrincipal();
        return user != null ? user.getName() : "&lt;NOT LOGGED IN&gt;";
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="json-シリアル化"><a class="anchor" href="#json-シリアル化"></a>JSON シリアル化</h3>
<div id="json" class="paragraph">
<p><code>io.quarkus:quarkus-resteasy-reactive</code> をインポートする代わりに、以下のモジュールのいずれかをインポートすることで、JSON のサポートを受けることができます。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. テーブルコンテキストオブジェクト</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">GAV</th>
<th class="tableblock halign-left valign-top">使用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.quarkus:quarkus-resteasy-reactive-jackson</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/FasterXML/jackson">Jackson support</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.quarkus:quarkus-resteasy-reactive-jsonb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://eclipse-ee4j.github.io/jsonb-api/">JSON-B support</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>どちらの場合も、これらのモジュールをインポートすると、 <a href="#resource-types">より具体的なシリアライゼーションで既に登録されていないすべての型</a>について HTTP メッセージ本文を JSON から読み取り、JSON にシリアル化できるようになります。</p>
</div>
<div class="sect3">
<h4 id="詳細なjackson固有の機能"><a class="anchor" href="#詳細なjackson固有の機能"></a>詳細なJackson固有の機能</h4>
<div class="paragraph">
<p><code>quarkus-resteasy-reactive-jackson</code> エクステンションを使用する場合、RESTEasy Reactive がサポートするいくつかの高度な機能があります。</p>
</div>
<div class="sect4">
<h5 id="secure-serialization"><a class="anchor" href="#secure-serialization"></a>安全なシリアル化</h5>
<div class="paragraph">
<p>JSON をシリアライズするために Jackson を使用する場合、RESTEasy Reactive は、現在のユーザのroleに基づいてシリアライズされるフィールドのセットを制限する機能を提供します。これは、返されるPOJOのフィールド（またはゲッター）を <code>@io.quarkus.resteasy.reactive.jackson.SecureField</code> でアノテーションするだけで実現できます。</p>
</div>
<div class="paragraph">
<p>簡単な例を挙げると、次のようになります:</p>
</div>
<div class="paragraph">
<p><code>Person</code> という名前のPOJOがあり、以下のようになっているとします:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import io.quarkus.resteasy.reactive.jackson.SecureField;

public class Person {

    @SecureField(rolesAllowed = "admin")
    private final Long id;
    private final String first;
    private final String last;

    public Person(Long id, String first, String last) {
        this.id = id;
        this.first = first;
        this.last = last;
    }

    public Long getId() {
        return id;
    }

    public String getFirst() {
        return first;
    }

    public String getLast() {
        return last;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Person</code> を使用する非常にシンプルな JAX-RS Resource は次のようになります:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("person")
public class Person {

    @Path("{id}")
    @GET
    public Person getPerson(Long id) {
        return new Person(id, "foo", "bar");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>アプリケーションのセキュリティーが設定されていると仮定すると (詳細は <a href="security">ガイド</a> を参照)、<code>admin</code> ロールを持つユーザーが <code>/person/1</code> に対して HTTP GET を実行すると、次のようなメッセージが表示されます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "id": 1,
  "first": "foo",
  "last": "bar"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>レスポンスを閉じます。</p>
</div>
<div class="paragraph">
<p>ただし、<code>admin</code> ロールを持たないユーザーは次のものを受け取ります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "first": "foo",
  "last": "bar"
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
No additional configuration needs to be applied for this secure serialization to take place. However, users can use the <code>@io.quarkus.resteasy.reactive.jackson.EnableSecureSerialization</code> and <code>@io.quarkus.resteasy.reactive.jackson.DisableSecureSerialization</code> annotation to opt in or out for specific JAX-RS Resource classes or methods.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="jsonview-support"><a class="anchor" href="#jsonview-support"></a>@JsonView support</h5>
<div class="paragraph">
<p>JAX-RS のメソッドに <a href="https://fasterxml.github.io/jackson-annotations/javadoc/2.10/com/fasterxml/jackson/annotation/JsonView.html">@JsonView</a> のアノテーションを付けると、返される POJO のシリアル化をメソッド単位でカスタマイズすることが可能です。これは例で説明するのが一番わかりやすいでしょう。</p>
</div>
<div class="paragraph">
<p><code>@JsonView</code> の一般的な使用法は、特定のメソッドの特定のフィールドを非表示にすることです。その流れの中で、2 つのビューを定義しましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Views {

    public static class Public {
    }

    public static class Private extends Public {
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>シリアル化中にフィールドを非表示にする <code>User</code> POJO があると仮定します。この簡単な例は次のとおりです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class User {

    @JsonView(Views.Private.class)
    public int id;

    @JsonView(Views.Public.class)
    public String name;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>このユーザーを返す JAX-RS メソッドによっては、シリアル化から <code>id</code> フィールドを除外したい場合があります。たとえば、安全でないメソッドでこのフィールドを公開しないようにしたい場合があります。RESTEasy Reactive でそれを実現する方法を、次の例に示します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@JsonView(Views.Public.class)
@GET
@Path("/public")
public User userPublic() {
    return testUser();
}

@JsonView(Views.Private.class)
@GET
@Path("/private")
public User userPrivate() {
    return testUser();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>結果の <code>userPublic</code> メソッドがシリアル化されると、<code>Public</code> ビューに含まれないため、<code>id</code> フィールドはレスポンスに含まれません。ただし、<code>userPrivate</code> の結果には、シリアル化されたときに期待されるように <code>id</code> が含まれます。</p>
</div>
</div>
<div class="sect4">
<h5 id="メソッドごとに完全にカスタマイズされたシリアル化"><a class="anchor" href="#メソッドごとに完全にカスタマイズされたシリアル化"></a>メソッドごとに完全にカスタマイズされたシリアル化</h5>
<div class="paragraph">
<p>JAX-RS のメソッドごとに POJO のシリアル化を完全にカスタマイズする必要がある場合があります。このような場合、<code>@io.quarkus.resteasy.reactive.jackson.CustomSerialization</code> アノテーションは素晴らしいツールで、自由に設定できる <code>com.fasterxml.jackson.databind.ObjectWriter</code> というメソッド単位で設定することが可能です。</p>
</div>
<div class="paragraph">
<p>ユースケースの例を次に示します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CustomSerialization(UnquotedFields.class)
@GET
@Path("/invalid-use-of-custom-serializer")
public User invalidUseOfCustomSerializer() {
    return testUser();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>ここで、<code>UnquotedFields</code> は次のように定義された <code>BiFunction</code> です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static class UnquotedFields implements BiFunction&lt;ObjectMapper, Type, ObjectWriter&gt; {

    @Override
    public ObjectWriter apply(ObjectMapper objectMapper, Type type) {
        return objectMapper.writer().without(JsonWriteFeature.QUOTE_FIELD_NAMES);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>基本的にこのクラスが行うことは、フィールド名に引用符を含めないよう Jackson に強制することです。</p>
</div>
<div class="paragraph">
<p>このカスタマイズは <code>@CustomSerialization(UnquotedFields.class)</code> を使用する JAX-RS メソッドのシリアル化にのみ行われることに注意することが重要です。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xml-シリアル化"><a class="anchor" href="#xml-シリアル化"></a>XML シリアル化</h3>
<div id="xml" class="paragraph">
<p>XML サポートを有効にするには、プロジェクトに <code>quarkus-resteasy-reactive-jaxb</code> エクステンションを追加します。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. テーブルコンテキストオブジェクト</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">GAV</th>
<th class="tableblock halign-left valign-top">使用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.quarkus:quarkus-resteasy-reactive-jaxb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javaee.github.io/jaxb-v2/">XML support</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>このモジュールをインポートすると、HTTP メッセージ本文を XML から読み込み、XML にシリアル化することができます (<a href="#resource-types">all the types not already registered with a more specific serialisation</a>)。</p>
</div>
<div class="sect3">
<h4 id="advanced-jaxb-specific-features"><a class="anchor" href="#advanced-jaxb-specific-features"></a>Advanced JAXB-specific features</h4>
<div class="paragraph">
<p>When using the <code>quarkus-resteasy-reactive-jaxb</code> extension there are some advanced features that RESTEasy Reactive supports.</p>
</div>
<div class="sect4">
<h5 id="inject-jaxb-components"><a class="anchor" href="#inject-jaxb-components"></a>Inject JAXB components</h5>
<div class="paragraph">
<p>The JAXB resteasy reactive extension will serialize and unserialize requests and responses transparently for users. However, if you need finer grain control over JAXB components, you can inject either the JAXBContext, Marshaller, or Unmarshaller components into your beans:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class MyService {

    @Inject
    JAXBContext jaxbContext;

    @Inject
    Marshaller marshaller;

    @Inject
    Unmarshaller unmarshaller;

    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Quarkus will automatically find all the classes annotated with <code>@XmlRootElement</code> and then bound them to the JAXB context.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="customize-the-jaxb-configuration"><a class="anchor" href="#customize-the-jaxb-configuration"></a>Customize the JAXB configuration</h5>
<div class="paragraph">
<p>To customize the JAXB configuration for either the JAXB context, and/or the Marshaller/Unmarshaller components, the suggested approach is to define a CDI bean of type <code>io.quarkus.jaxb.runtime.JaxbContextCustomizer</code>.</p>
</div>
<div class="paragraph">
<p>カスタムモジュールを登録する必要がある場合の例は次のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Singleton
public class RegisterCustomModuleCustomizer implements JaxbContextCustomizer {

    // For JAXB context configuration
    @Override
    public void customizeContextProperties(Map&lt;String, Object&gt; properties) {

    }

    // For Marshaller configuration
    @Override
    public void customizeMarshaller(Marshaller marshaller) throws PropertyException {
        marshaller.setProperty("jaxb.formatted.output", Boolean.TRUE);
    }

    // For Unmarshaller configuration
    @Override
    public void customizeUnmarshaller(Unmarshaller unmarshaller) throws PropertyException {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It&#8217;s not necessary to implement all three methods, but only the want you need.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Alternatively, you can provide your own <code>JAXBContext</code> bean by doing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class CustomJaxbContext {

    // Replaces the CDI producer for JAXBContext built into Quarkus
    @Singleton
    @Produces
    JAXBContext jaxbContext() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Note that if you provide your custom JAXB context instance, you will need to register the classes you want to use for the XML serialization. This means that Quarkus will not update your custom JAXB context instance with the auto-discovered classes.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="web-リンクのサポート"><a class="anchor" href="#web-リンクのサポート"></a>Web リンクのサポート</h3>
<div id="links" class="paragraph">
<p>Web リンクのサポートを有効にするには、プロジェクトに <code>quarkus-resteasy-reactive-links</code> エクステンションを追加します。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8. テーブルコンテキストオブジェクト</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">GAV</th>
<th class="tableblock halign-left valign-top">使用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.quarkus:quarkus-resteasy-reactive-links</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.w3.org/wiki/LinkHeader">Web Links support</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>このモジュールをインポートすると、エンドポイントリソースに <code>@InjectRestLinks</code> アノテーションを付けるだけで、レスポンスの HTTP ヘッダに Web リンクを挿入することができるようになります。返される Web リンクを宣言するには、リンクされたメソッドで <code>@RestLink</code> アノテーションを使用する必要があります。この例としては、以下のようなものがあります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Path("/records")
public class RecordsResource {

    @GET
    @RestLink(rel = "list")
    @InjectRestLinks
    public List&lt;Record&gt; getAll() {
        // ...
    }

    @GET
    @Path("/{id}")
    @RestLink(rel = "self")
    @InjectRestLinks(RestLinkType.INSTANCE)
    public TestRecord get(@PathParam("id") int id) {
        // ...
    }

    @PUT
    @Path("/{id}")
    @RestLink
    @InjectRestLinks(RestLinkType.INSTANCE)
    public TestRecord update(@PathParam("id") int id) {
        // ...
    }

    @DELETE
    @Path("/{id}")
    @RestLink
    public TestRecord delete(@PathParam("id") int id) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上記のリソース内でメソッド <code>getAll</code> によって定義されたエンドポイント <code>/records</code> を curl を使用して呼び出すと、Web リンクヘッダーが取得されます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">&amp; curl -i localhost:8080/records
Link: &lt;http://localhost:8080/records&gt;; rel="list"</code></pre>
</div>
</div>
<div class="paragraph">
<p>このリソースはタイプ <code>Record</code> の単一のインスタンスを返さないため、メソッド <code>get</code>、<code>update</code>、および <code>delete</code> のリンクは挿入されません。これで、エンドポイント <code>/records/1</code> を呼び出すと、次の Web リンクが表示されます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">&amp; curl -i localhost:8080/records/1
Link: &lt;http://localhost:8080/records&gt;; rel="list"
Link: &lt;http://localhost:8080/records/1&gt;; rel="self"
Link: &lt;http://localhost:8080/records/1&gt;; rel="update"
Link: &lt;http://localhost:8080/records/1&gt;; rel="delete"</code></pre>
</div>
</div>
<div class="paragraph">
<p>最後に、delete リソースを呼び出すとき、メソッド <code>delete</code> には <code>@InjectRestLinks</code> アノテーションが付けられていないため、Web リンクは表示されません。</p>
</div>
<div class="sect3">
<h4 id="web-リンクレジストリーへのプログラムによるアクセス"><a class="anchor" href="#web-リンクレジストリーへのプログラムによるアクセス"></a>Web リンクレジストリーへのプログラムによるアクセス</h4>
<div class="paragraph">
<p><code>RestLinksProvider</code> Bean を挿入するだけで、プログラムで Web リンクレジストリーにアクセスできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Path("/records")
public class RecordsResource {

    @Inject
    RestLinksProvider linksProvider;

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>タイプ <code>RestLinksProvider</code> の挿入された Bean を使用すると、メソッド <code>RestLinksProvider.getTypeLinks</code> を使用してタイプごとにリンクを取得するか、メソッド <code>RestLinksProvider.getInstanceLinks</code> を使用して具象インスタンスによってリンクを取得できます。</p>
</div>
</div>
<div class="sect3">
<h4 id="json-ハイパーテキストアプリケーション言語-hal-のサポート"><a class="anchor" href="#json-ハイパーテキストアプリケーション言語-hal-のサポート"></a>JSON ハイパーテキストアプリケーション言語 (HAL) のサポート</h4>
<div class="paragraph">
<p><a href="https://tools.ietf.org/id/draft-kelly-json-hal-01.html">HAL</a> 標準は、Web リンクを表す単純な形式です。</p>
</div>
<div class="paragraph">
<p>HAL サポートを有効にするには、プロジェクトに <code>quarkus-hal</code> エクステンションを追加します。また、HAL には JSON サポートが必要なため、<code>quarkus-resteasy-reactive-jsonb</code> または <code>quarkus-resteasy-reactive-jackson</code> エクステンションを追加する必要があります。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 9. テーブルコンテキストオブジェクト</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">GAV</th>
<th class="tableblock halign-left valign-top">使用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.quarkus:quarkus-hal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://tools.ietf.org/id/draft-kelly-json-hal-01.html">HAL</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>エクステンションを追加した後、REST リソースにアノテーションを付けて、メディアタイプ <code>application/hal+json</code> を生成できます (または RestMediaType.APPLICATION_HAL_JSON を使用します)。例えば:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Path("/records")
public class RecordsResource {

    @GET
    @Produces({ MediaType.APPLICATION_JSON, RestMediaType.APPLICATION_HAL_JSON })
    @RestLink(rel = "list")
    @InjectRestLinks
    public List&lt;Record&gt; getAll() {
        // ...
    }

    @GET
    @Produces({ MediaType.APPLICATION_JSON, RestMediaType.APPLICATION_HAL_JSON })
    @Path("/{id}")
    @RestLink(rel = "self")
    @InjectRestLinks(RestLinkType.INSTANCE)
    public TestRecord get(@PathParam("id") int id) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>ここで、エンドポイント <code>/records</code> と <code>/records/{id}</code> は、<code>json</code> と <code>hal + json</code> の両方のメディアタイプを受け入れて、Hal 形式でレコードを出力します。</p>
</div>
<div class="paragraph">
<p>たとえば、curl を使用して <code>/records</code> エンドポイントを呼び出してレコードのリストを返す場合、HAL 形式は次のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">&amp; curl -H "Accept:application/hal+json" -i localhost:8080/records
{
    "_embedded": {
        "items": [
            {
                "id": 1,
                "slug": "first",
                "value": "First value",
                "_links": {
                    "self": {
                        "href": "http://localhost:8081/records/1"
                    },
                    "list": {
                        "href": "http://localhost:8081/records"
                    }
                }
            },
            {
                "id": 2,
                "slug": "second",
                "value": "Second value",
                "_links": {
                    "self": {
                        "href": "http://localhost:8081/records/2"
                    },
                    "list": {
                        "href": "http://localhost:8081/records"
                    }
                }
            }
        ]
    },
    "_links": {
        "list": {
            "href": "http://localhost:8081/records"
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>1 つのインスタンスのみを返すリソース <code>/records/1</code> を呼び出すと、出力は次のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">&amp; curl -H "Accept:application/hal+json" -i localhost:8080/records/1
{
    "id": 1,
    "slug": "first",
    "value": "First value",
    "_links": {
        "self": {
            "href": "http://localhost:8081/records/1"
        },
        "list": {
            "href": "http://localhost:8081/records"
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, you can also provide additional HAL links programmatically in your resource just by returning either <code>HalCollectionWrapper</code> (to return a list of entities) or <code>HalEntityWrapper</code> (to return a single object) as described in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Path("/records")
public class RecordsResource {

    @Inject
    RestLinksProvider linksProvider;

    @GET
    @Produces({ MediaType.APPLICATION_JSON, RestMediaType.APPLICATION_HAL_JSON })
    @RestLink(rel = "list")
    public HalCollectionWrapper getAll() {
        List&lt;Record&gt; list = // ...
        HalCollectionWrapper halCollection = new HalCollectionWrapper(list, "collectionName", linksProvider.getTypeLinks(Record.class));
        halCollection.addLinks(Link.fromPath("/records/1").rel("first-record").build());
        return halCollection;
    }

    @GET
    @Produces({ MediaType.APPLICATION_JSON, RestMediaType.APPLICATION_HAL_JSON })
    @Path("/{id}")
    @RestLink(rel = "self")
    @InjectRestLinks(RestLinkType.INSTANCE)
    public HalEntityWrapper get(@PathParam("id") int id) {
        Record entity = // ...
        HalEntityWrapper halEntity = new HalEntityWrapper(entity, linksProvider.getInstanceLinks(entity));
        halEntity.addLinks(Link.fromPath("/records/1/parent").rel("parent-record").build());
        return halEntity;
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cors-フィルター"><a class="anchor" href="#cors-フィルター"></a>CORS フィルター</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">クロスオリジンリソース共有</a> (CORS)は、ウェブページ上の制限されたリソースを、最初のリソースが提供されたドメイン以外の別のドメインから要求できるようにするメカニズムです。</p>
</div>
<div class="paragraph">
<p>Quarkus には、HTTP レイヤーレベルの CORS フィルターが付属しています。使用方法については、<a href="http-reference#cors-filter">HTTPリファレンスドキュメント</a> を参照してください。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="より高度な使用法"><a class="anchor" href="#より高度な使用法"></a>より高度な使用法</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ここでは、最初は知る必要がないかもしれませんが、より複雑なユースケースに役立つ可能性のある、より詳細なトピックをいくつか紹介します。</p>
</div>
<div class="sect2">
<h3 id="実行モデルブロッキング非ブロッキング"><a class="anchor" href="#実行モデルブロッキング非ブロッキング"></a>実行モデル、ブロッキング、非ブロッキング</h3>
<div id="execution-model" class="paragraph">
<p>RESTEasy Reactive は、次の 2 つのメインスレッドタイプを使用して実装されます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>イベントループスレッド: 特に、HTTP リクエストからバイトを読み取る役割を果たします。
HTTP レスポンスにバイトを書き戻す</p>
</li>
<li>
<p>ワーカースレッド: プールされ、長時間実行される操作の負荷を軽減するために使用できます</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>イベントループスレッド (IO スレッドとも呼ばれます) は、すべての IO 操作を非同期で実際に実行し、それらの IO 操作の完了に関心のあるリスナーをトリガーする役割を果たします。</p>
</div>
<div class="paragraph">
<p>デフォルトでは、スレッド RESTEasy Reactive は、メソッドのシグネチャーに応じてエンドポイントメソッドを実行します。メソッドが次のタイプのいずれかを返す場合、それは非ブロッキングと見なされ、デフォルトで IO スレッドで実行されます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>io.smallrye.mutiny.Uni</code></p>
</li>
<li>
<p><code>io.smallrye.mutiny.Multi</code></p>
</li>
<li>
<p><code>java.util.concurrent.CompletionStage</code></p>
</li>
<li>
<p><code>org.reactivestreams.Publisher</code></p>
</li>
<li>
<p>Kotlin の <code>suspended</code> メソッド</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This 'best guess' approach means that the majority of operations will run on the correct thread by default. If you are writing reactive code then your method will generally return one of these types, and will be executed on the IO thread. If you are writing blocking code your methods will usually return the result directly, and these will be run on a worker thread.</p>
</div>
<div class="paragraph">
<p><a href="https://javadoc.io/doc/io.smallrye.common/smallrye-common-annotation/1.5.0/io/smallrye/common/annotation/Blocking.html"><code>@Blocking</code></a> アノテーションと <a href="https://javadoc.io/doc/io.smallrye.common/smallrye-common-annotation/1.5.0/io/smallrye/common/annotation/NonBlocking.html"><code>@NonBlocking</code></a> アノテーションを使用してこの動作をオーバーライドできます。これは、メソッド、クラス、または <code>javax.ws.rs.core.Application</code> レベルで適用できます。</p>
</div>
<div class="paragraph">
<p>以下の例は、デフォルトの動作をオーバーライドし、<code>Uni</code> を返しても、常にワーカースレッドで実行されます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

import io.smallrye.common.annotation.Blocking;

@Path("yawn")
public class Endpoint {

    @Blocking
    @GET
    public Uni&lt;String&gt; blockingHello() throws InterruptedException {
        // do a blocking operation
        Thread.sleep(1000);
        return Uni.createFrom().item("Yaaaawwwwnnnnnn…");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most of the time, there are ways to achieve the same blocking operations in an asynchronous/reactive way, using <a href="https://smallrye.io/smallrye-mutiny/">Mutiny</a>, <a href="https://hibernate.org/reactive/">Hibernate Reactive</a> or any of the <a href="quarkus-reactive-architecture#quarkus-extensions-enabling-reactive">Quarkus Reactive extensions</a> for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import java.time.Duration;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

import io.smallrye.mutiny.Uni;

@Path("yawn")
public class Endpoint {

    @GET
    public Uni&lt;String&gt; blockingHello() throws InterruptedException {
        return Uni.createFrom().item("Yaaaawwwwnnnnnn…")
                // do a non-blocking sleep
                .onItem().delayIt().by(Duration.ofSeconds(2));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>メソッドまたはクラスに <code>javax.transaction.Transactional</code> アノテーションが付けられている場合、それもブロッキングメソッドとして扱われます。これは、JTA がブロッキングテクノロジーであり、Hibernate や JDBC などの他のブロッキングテクノロジーで一般的に使用されているためです。クラスでの明示的な <code>@Blocking</code> または <code>@NonBlocking</code> は、この動作をオーバーライドします。</p>
</div>
<div class="sect3">
<h4 id="デフォルトの動作のオーバーライド"><a class="anchor" href="#デフォルトの動作のオーバーライド"></a>デフォルトの動作のオーバーライド</h4>
<div class="paragraph">
<p>デフォルトの動作をオーバーライドする場合は、アプリケーションの <code>javax.ws.rs.core.Application</code> サブクラスに <code>@Blocking</code> または <code>@NonBlocking</code> のアノテーションを付けることができます。これにより、明示的なアノテーションを付与していないすべてのメソッドのデフォルトが設定されます。</p>
</div>
<div class="paragraph">
<p>動作は、クラスまたはメソッドレベルで直接アノテーションを付けることでオーバーライドできますが、アノテーションのないすべてのエンドポイントは、メソッドのシグネチャーに関係なく、デフォルトに従うようになります。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="exception-mapping"><a class="anchor" href="#exception-mapping"></a>例外のマッピング</h3>
<div class="paragraph">
<p>もしアプリケーションがエラー時に正規の HTTP コード以外を返す必要がある場合、最善の方法は、フレームワークが <a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/WebApplicationException.html"><code>WebApplicationException</code></a> またはそのサブタイプを使用して適切な HTTP レスポンスを送信する結果となる例外を投げることです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import javax.ws.rs.BadRequestException;
import javax.ws.rs.GET;
import javax.ws.rs.NotFoundException;
import javax.ws.rs.Path;

@Path("cheeses/{cheese}")
public class Endpoint {

    @GET
    public String findCheese(String cheese) {
        if(cheese == null)
            // send a 400
            throw new BadRequestException();
        if(!cheese.equals("camembert"))
            // send a 404
            throw new NotFoundException("Unknown cheese: " + cheese);
        return "Camembert is a very nice cheese";
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>エンドポイントメソッドが JAX-RS を認識しない別のサービスレイヤーに呼び出しを委任している場合は、サービス例外を HTTP レスポンスに変換する方法が必要であり、メソッドに <a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive/2.12.1.Final/org/jboss/resteasy/reactive/server/ServerExceptionMapper.html"><code>@ServerExceptionMapper</code></a> を使用してこれを行うことができます。例外マッパーは処理する例外タイプのパラメーターが 1 つあり、その例外を <a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/RestResponse.html"><code>RestResponse</code></a> (あるいは <a href="https://javadoc.io/doc/io.smallrye.reactive/mutiny/1.6.0/io/smallrye/mutiny/Uni.html"><code>Uni&lt;RestResponse&lt;?&gt;&gt;</code></a>) に変換します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import java.util.Map;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import javax.ws.rs.BadRequestException;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;

import org.jboss.resteasy.reactive.server.ServerExceptionMapper;
import org.jboss.resteasy.reactive.RestResponse;

class UnknownCheeseException extends RuntimeException {
    public final String name;

    public UnknownCheeseException(String name) {
        this.name = name;
    }
}

@ApplicationScoped
class CheeseService {
    private static final Map&lt;String, String&gt; cheeses =
            Map.of("camembert", "Camembert is a very nice cheese",
                   "gouda", "Gouda is acceptable too, especially with cumin");

    public String findCheese(String name) {
        String ret = cheeses.get(name);
        if(ret != null)
            return ret;
        throw new UnknownCheeseException(name);
    }
}

@Path("cheeses/{cheese}")
public class Endpoint {

    @Inject
    CheeseService cheeses;

    @ServerExceptionMapper
    public RestResponse&lt;String&gt; mapException(UnknownCheeseException x) {
        return RestResponse.status(Response.Status.NOT_FOUND, "Unknown cheese: " + x.name);
    }

    @GET
    public String findCheese(String cheese) {
        if(cheese == null)
            // send a 400
            throw new BadRequestException();
        return cheeses.findCheese(cheese);
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
REST エンドポイントクラスで定義された例外マッパーは、例外が同じクラスで出力された場合にのみ呼び出されます。グローバル例外マッパーを定義する場合は、REST エンドポイントクラスの外部で定義するだけです。
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import org.jboss.resteasy.reactive.server.ServerExceptionMapper;
import org.jboss.resteasy.reactive.RestResponse;

class ExceptionMappers {
    @ServerExceptionMapper
    public RestResponse&lt;String&gt; mapException(UnknownCheeseException x) {
        return RestResponse.status(Response.Status.NOT_FOUND, "Unknown cheese: " + x.name);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="/specs/jaxrs/2.1/index.html#exceptionmapper">JAX-RSの方式で例外マッパー</a> を宣言することもできます。</p>
</div>
<div class="paragraph">
<p>例外マッパーは、次のパラメータータイプのいずれかを宣言できます。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 10. テーブル例外マッパーパラメーター</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">タイプe</th>
<th class="tableblock halign-left valign-top">使用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">例外タイプ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">処理する例外タイプを定義します</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#context-objects">Context objects</a>&gt; のいずれか</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/container/ContainerRequestContext.html"><code>ContainerRequestContext</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">現在のリクエストにアクセスするためのコンテキストオブジェクト</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>次の戻り値の型のいずれかを宣言できます。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 11. テーブル 例外マッパーの戻り値の型</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">タイプe</th>
<th class="tableblock halign-left valign-top">使用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/RestResponse.html"><code>RestResponse</code></a> または <a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/core/Response.html"><code>Response</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">例外が発生したときにクライアントに送信するレスポンス</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/io.smallrye.reactive/mutiny/1.6.0/io/smallrye/mutiny/Uni.html"><code>Uni&lt;RestResponse&gt;</code></a> または <a href="https://javadoc.io/doc/io.smallrye.reactive/mutiny/1.6.0/io/smallrye/mutiny/Uni.html"><code>Uni&lt;Response&gt;</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">例外が発生したときにクライアントに送信する非同期レスポンス</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When an exception occurs, RESTEasy Reactive does not log it by default (for security reasons). This can sometimes make it hard to understand why certain exception handling code was invoked (or not invoked). To make RESTEasy Reactive log the actual exception before an exception mapping code is run the <code>org.jboss.resteasy.reactive.common.core.AbstractResteasyReactiveContext</code> log category can be set to <code>DEBUG</code> like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.log.category."org.jboss.resteasy.reactive.common.core.AbstractResteasyReactiveContext".level=DEBUG</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="リクエストまたはレスポンスフィルター"><a class="anchor" href="#リクエストまたはレスポンスフィルター"></a>リクエストまたはレスポンスフィルター</h3>
<div class="sect3">
<h4 id="アノテーション経由"><a class="anchor" href="#アノテーション経由"></a>アノテーション経由</h4>
<div class="paragraph">
<p>リクエスト処理の次のフェーズで呼び出される関数を宣言できます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>エンドポイントメソッドが識別される前: 事前ルーティングリクエストフィルター</p>
</li>
<li>
<p>ルーティング後、エンドポイントメソッドが呼び出される前: 通常のリクエストフィルター</p>
</li>
<li>
<p>エンドポイントメソッドが呼び出された後: レスポンスフィルター</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>これらのフィルターを使用すると、リクエスト URI、HTTP メソッドの調査、ルーティングへの影響、リクエストヘッダーの検索または変更、リクエストの中止、レスポンスの変更など、さまざまなことができます。</p>
</div>
<div class="paragraph">
<p>リクエストフィルターは、 <a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive/2.12.1.Final/org/jboss/resteasy/reactive/server/ServerRequestFilter.html"><code>@ServerRequestFilter</code></a> アノテーションで宣言することが出来ます:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import java.util.Optional;

class Filters {

    @ServerRequestFilter(preMatching = true)
    public void preMatchingFilter(ContainerRequestContext requestContext) {
        // make sure we don't lose cheese lovers
        if("yes".equals(requestContext.getHeaderString("Cheese"))) {
            requestContext.setRequestUri(URI.create("/cheese"));
        }
    }

    @ServerRequestFilter
    public Optional&lt;RestResponse&lt;Void&gt;&gt; getFilter(ContainerRequestContext ctx) {
        // only allow GET methods for now
        if(ctx.getMethod().equals(HttpMethod.GET)) {
            return Optional.of(RestResponse.status(Response.Status.METHOD_NOT_ALLOWED));
        }
        return Optional.empty();
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>リクエストフィルターは通常、リクエストを処理するメソッドが実行されるのと同じスレッドで実行されます。つまり、リクエストを処理するメソッドが <code>@Blocking</code> でアノテーションされている場合は、フィルターもワーカスレッドで実行されます。メソッドに <code>@NonBlocking</code> のアノテーションがある場合 (あるいは全くアノテーションがない場合)、フィルターは同じイベントループのスレッドで実行されます。</p>
</div>
<div class="paragraph">
<p>しかし、リクエストを処理するメソッドがワーカスレッドで実行されるにも関わらず、フィルターをイベントループで実行する必要がある場合、<code>@ServerRequestFilter (nonBlocking=true)</code> を使用することができます。しかし、これらのフィルターはこの設定を使わず、ワーカースレッドで実行される <strong>どんな</strong> フィルターよりも前に実行される必要があることに注意してください。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>同様に、レスポンスフィルターは <a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive/2.12.1.Final/org/jboss/resteasy/reactive/server/ServerResponseFilter.html"><code>@ServerResponseFilter</code></a> アノテーションで宣言することが可能です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class Filters {
    @ServerResponseFilter
    public void getFilter(ContainerResponseContext responseContext) {
        Object entity = responseContext.getEntity();
        if(entity instanceof String) {
            // make it shout
            responseContext.setEntity(((String)entity).toUpperCase());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>フィルターは、次のパラメータータイプのいずれかを宣言できます。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 12. テーブルフィルターパラメーター</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">タイプe</th>
<th class="tableblock halign-left valign-top">使用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#context-objects">Context objects</a>&gt; のいずれか</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/container/ContainerRequestContext.html"><code>ContainerRequestContext</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">現在のリクエストにアクセスするためのコンテキストオブジェクト</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/container/ContainerResponseContext.html"><code>ContainerResponseContext</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">現在のレスポンスにアクセスするためのコンテキストオブジェクト</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Throwable.html"><code>Throwable</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">出力された例外、または <code>null</code> (レスポンスフィルターの場合のみ)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>次の戻り値の型のいずれかを宣言できます。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 13. テーブルフィルターの戻り値の型</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">タイプe</th>
<th class="tableblock halign-left valign-top">使用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/RestResponse.html"><code>RestResponse&lt;?&gt;</code></a> または <a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/core/Response.html"><code>Response</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">フィルターチェーンを続行する代わりにクライアントに送信するレスポンス、またはフィルターチェーンを続行する必要がある場合は null</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.html"><code>Optional&lt;RestResponse&lt;?&gt;&gt;</code></a> または <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.html"><code>Optional&lt;Response&gt;</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">フィルターチェーンを続行する代わりにクライアントに送信するオプションのレスポンス、またはフィルターチェーンを続行する必要がある場合は空の値</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://javadoc.io/doc/io.smallrye.reactive/mutiny/1.6.0/io/smallrye/mutiny/Uni.html"><code>Uni&lt;RestResponse&lt;?&gt;&gt;</code></a> または <a href="https://javadoc.io/doc/io.smallrye.reactive/mutiny/1.6.0/io/smallrye/mutiny/Uni.html"><code>Uni&lt;Response&gt;</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">フィルターチェーンを続行する代わりにクライアントに送信する非同期レスポンス、またはフィルターチェーンを続行する必要がある場合は null</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/NameBinding.html"><code>@NameBinding</code></a> メタアノテーションを使用して、フィルターが実行されるリソースメソッドを制限できます。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="jax-rs-の方法"><a class="anchor" href="#jax-rs-の方法"></a>JAX-RS の方法</h4>
<div class="paragraph">
<p><a href="/specs/jaxrs/2.1/index.html#filters">JAX-RS方式でリクエストフィルタ、レスポンスフィルタを宣言する</a>こともできます。</p>
</div>
<div class="paragraph">
<p>HTTP リクエストとレスポンスの両方とも、それぞれ <code>ContainerRequestFilter</code> または <code>ContainerResponseFilter</code> の実装を提供することで、 インターセプトすることができます。これらのフィルタは、メッセージに関連付けられたメタデータを処理するのに適しています。HTTP ヘッダ、クエリパラメーター、メディアタイプ、その他のメタデータです。また、ユーザーがエンドポイントにアクセスする権限を持っていない場合など、リクエスト処理を中止する機能も持っています。</p>
</div>
<div class="paragraph">
<p><code>ContainerRequestFilter</code> を使用して、サービスにロギング機能を追加してみましょう。 <code>ContainerRequestFilter</code> を実装して、 <code>@Provider</code> アノテーションをつけることで実現できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest.json;

import io.vertx.core.http.HttpServerRequest;
import org.jboss.logging.Logger;

import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.container.ContainerRequestFilter;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.UriInfo;
import javax.ws.rs.ext.Provider;

@Provider
public class LoggingFilter implements ContainerRequestFilter {

    private static final Logger LOG = Logger.getLogger(LoggingFilter.class);

    @Context
    UriInfo info;

    @Context
    HttpServerRequest request;

    @Override
    public void filter(ContainerRequestContext context) {

        final String method = context.getMethod();
        final String path = info.getPath();
        final String address = request.remoteAddress().toString();

        LOG.infof("Request %s %s from IP %s", method, path, address);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これで、RESTメソッドが呼び出されるたびに、リクエストがコンソールにログとして記録されるようになりました。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">2019-06-05 12:44:26,526 INFO  [org.acm.res.jso.LoggingFilter] (executor-thread-1) Request GET /legumes from IP 127.0.0.1
2019-06-05 12:49:19,623 INFO  [org.acm.res.jso.LoggingFilter] (executor-thread-1) Request GET /fruits from IP 0:0:0:0:0:0:0:1
2019-06-05 12:50:44,019 INFO  [org.acm.res.jso.LoggingFilter] (executor-thread-1) Request POST /fruits from IP 0:0:0:0:0:0:0:1
2019-06-05 12:51:04,485 INFO  [org.acm.res.jso.LoggingFilter] (executor-thread-1) Request GET /fruits from IP 127.0.0.1</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="リーダーとライター-マッピングエンティティーと-http-本文"><a class="anchor" href="#リーダーとライター-マッピングエンティティーと-http-本文"></a>リーダーとライター: マッピングエンティティーと HTTP 本文</h3>
<div id="readers-writers" class="paragraph">
<p>Whenever your endpoint methods return an object (of when they return a <a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/2.12.1.Final/org/jboss/resteasy/reactive/RestResponse.html"><code>RestResponse&lt;?&gt;</code></a> or <a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/core/Response.html"><code>Response</code></a> with an entity), RESTEasy Reactive will look for a way to map that into an HTTP response body.</p>
</div>
<div class="paragraph">
<p>同様に、エンドポイントメソッドがオブジェクトをパラメーターとして受け取る場合は常に、HTTP リクエストの本文をそのオブジェクトにマッピングする方法を探します。</p>
</div>
<div class="paragraph">
<p>これは、<a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/ext/MessageBodyReader.html"><code>MessageBodyReader</code></a> と <a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/ext/MessageBodyWriter.html"><code>MessageBodyWriter</code></a> インターフェイスのプラグインシステムによって行われ、どの Java タイプからどのメディアタイプへマッピングするか、またそのタイプの Java インスタンスとどのように HTTP 本文をやり取りするかを定義する役割を持っています。</p>
</div>
<div class="paragraph">
<p>たとえば、エンドポイントに独自の <code>Cheese</code> タイプがある場合:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import javax.ws.rs.GET;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;

class Cheese {
    public String name;

    public Cheese(String name) {
        this.name = name;
    }
}

@Path("cheese")
public class Endpoint {

    @GET
    public Cheese sayCheese() {
        return new Cheese("Cheeeeeese");
    }

    @PUT
    public void addCheese(Cheese cheese) {
        System.err.println("Received a new cheese: " + cheese.name);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>次に、 <a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/ext/Provider.html"><code>@Provider</code></a> でアノテーションを付けたボディリーダー/ライターを使用して読み取りと書き込みの方法を定義できます:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;

import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.MultivaluedMap;
import javax.ws.rs.ext.MessageBodyReader;
import javax.ws.rs.ext.MessageBodyWriter;
import javax.ws.rs.ext.Provider;

@Provider
public class CheeseBodyHandler implements MessageBodyReader&lt;Cheese&gt;,
                                           MessageBodyWriter&lt;Cheese&gt; {

    @Override
    public boolean isWriteable(Class&lt;?&gt; type, Type genericType,
                               Annotation[] annotations, MediaType mediaType) {
        return type == Cheese.class;
    }

    @Override
    public void writeTo(Cheese t, Class&lt;?&gt; type, Type genericType,
                        Annotation[] annotations, MediaType mediaType,
                        MultivaluedMap&lt;String, Object&gt; httpHeaders,
                        OutputStream entityStream)
            throws IOException, WebApplicationException {
        entityStream.write(("[CheeseV1]" + t.name)
                           .getBytes(StandardCharsets.UTF_8));
    }

    @Override
    public boolean isReadable(Class&lt;?&gt; type, Type genericType,
                              Annotation[] annotations, MediaType mediaType) {
        return type == Cheese.class;
    }

    @Override
    public Cheese readFrom(Class&lt;Cheese&gt; type, Type genericType,
                            Annotation[] annotations, MediaType mediaType,
                            MultivaluedMap&lt;String, String&gt; httpHeaders,
                            InputStream entityStream)
            throws IOException, WebApplicationException {
        String body = new String(entityStream.readAllBytes(), StandardCharsets.UTF_8);
        if(body.startsWith("[CheeseV1]"))
            return new Cheese(body.substring(11));
        throw new IOException("Invalid cheese: " + body);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>ライターのパフォーマンスを最大限に高めたい場合は、 <a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/ext/MessageBodyWriter.html"><code>MessageBodyWriter</code></a> の代わりに <a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive/2.12.1.Final/org/jboss/resteasy/reactive/server/spi/ServerMessageBodyWriter.html"><code>ServerMessageBodyWriter</code></a> を拡張できます。こちらでは、リフレクションの使用を減らし、ブロッキング IO レイヤーをバイパスできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;

import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.MultivaluedMap;
import javax.ws.rs.ext.MessageBodyReader;
import javax.ws.rs.ext.Provider;

import org.jboss.resteasy.reactive.server.spi.ResteasyReactiveResourceInfo;
import org.jboss.resteasy.reactive.server.spi.ServerMessageBodyWriter;
import org.jboss.resteasy.reactive.server.spi.ServerRequestContext;

@Provider
public class CheeseBodyHandler implements MessageBodyReader&lt;Cheese&gt;,
                                           ServerMessageBodyWriter&lt;Cheese&gt; {

    // …

    @Override
    public boolean isWriteable(Class&lt;?&gt; type, ResteasyReactiveResourceInfo target,
                               MediaType mediaType) {
        return type == Cheese.class;
    }

    @Override
    public void writeResponse(Cheese t, ServerRequestContext context)
      throws WebApplicationException, IOException {
        context.serverResponse().end("[CheeseV1]" + t.name);
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
プロバイダークラスに <a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/Consumes.html"><code>Consumes</code></a>/<a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/Produces.html"><code>Produces</code></a> アノテーションを追加すると、リーダー/ライターが適用するコンテンツタイプを制限することができます。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="リーダーおよびライターインターセプター"><a class="anchor" href="#リーダーおよびライターインターセプター"></a>リーダーおよびライターインターセプター</h3>
<div class="paragraph">
<p>リクエストとレスポンスをインターセプトできるように、<a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/ext/Provider.html"><code>@Provider</code></a>でアノテーションが付けられたクラスの <a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/ext/ReaderInterceptor.html"><code>ReaderInterceptor</code></a> または <a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/ext/WriterInterceptor.html"><code>WriterInterceptor</code></a> を拡張することによってリーダーとライターをインターセプトすることもできます。</p>
</div>
<div class="paragraph">
<p>このエンドポイントを見ると、次のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import javax.ws.rs.GET;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;

@Path("cheese")
public class Endpoint {

    @GET
    public String sayCheese() {
        return "Cheeeeeese";
    }

    @PUT
    public void addCheese(String cheese) {
        System.err.println("Received a new cheese: " + cheese);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>次のようなリーダーとライターのインターセプターを追加できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import java.io.IOException;

import javax.ws.rs.WebApplicationException;
import javax.ws.rs.ext.Provider;
import javax.ws.rs.ext.ReaderInterceptor;
import javax.ws.rs.ext.ReaderInterceptorContext;
import javax.ws.rs.ext.WriterInterceptor;
import javax.ws.rs.ext.WriterInterceptorContext;

@Provider
public class CheeseIOInterceptor implements ReaderInterceptor, WriterInterceptor {

    @Override
    public void aroundWriteTo(WriterInterceptorContext context)
      throws IOException, WebApplicationException {
        System.err.println("Before writing " + context.getEntity());
        context.proceed();
        System.err.println("After writing " + context.getEntity());
    }

    @Override
    public Object aroundReadFrom(ReaderInterceptorContext context)
      throws IOException, WebApplicationException {
        System.err.println("Before reading " + context.getGenericType());
        Object entity = context.proceed();
        System.err.println("After reading " + entity);
        return entity;
    }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="resteasy-reactive-および-rest-client-reactive-の相互作用"><a class="anchor" href="#resteasy-reactive-および-rest-client-reactive-の相互作用"></a>RESTEasy Reactive および REST Client Reactive の相互作用</h4>
<div class="paragraph">
<p>Quarkus では、RESTEasy Reactive エクステンションと <a href="rest-client-reactive">REST クライアントリアクティブエクステンション</a> は同じインフラストラクチャを共有しています。この考慮の重要な結果の一つは、(JAX-RS の意味での) プロバイダーのリストを共有しているということです。</p>
</div>
<div class="paragraph">
<p>例えば、 <code>WriterInterceptor</code> を宣言した場合、デフォルトではサーバーの呼び出しとクライアントの呼び出しの両方をインターセプトしますが、これは望ましい動作ではないかもしれません。</p>
</div>
<div class="paragraph">
<p>しかし、このデフォルトの動作を変更してプロバイダを制約することができます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>プロバイダに <code>@ConstrainedTo(RuntimeType.SERVER)</code> アノテーションを追加することで、 <strong>サーバー</strong> コールのみを考慮します。</p>
</li>
<li>
<p>プロバイダに <code>@ConstrainedTo(RuntimeType.CLIENT)</code> アノテーションを追加することで、 <strong>クライアント</strong> コールのみを考慮します。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="パラメータマッピング"><a class="anchor" href="#パラメータマッピング"></a>パラメータマッピング</h3>
<div class="paragraph">
<p>すべての<a href="#request-parameters">リクエストパラメーター</a> は <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html"><code>String</code></a> として宣言することができます。しかし、それだけでなく、次のいずれかの型でも宣言できます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/ext/ParamConverterProvider.html"><code>ParamConverterProvider</code></a> を通じて登録済の <a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/ext/ParamConverter.html"><code>ParamConverter</code></a> が存在する型</p>
</li>
<li>
<p>プリミティブ型</p>
</li>
<li>
<p>単一の <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html"><code>String</code></a> 引数を受け入れるコンストラクターを持つ型。</p>
</li>
<li>
<p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html"><code>String</code></a> という引数を持ち、その型のインスタンスを返す <code>valueOf</code> または <code>fromString</code> という名前の静的メソッドを持っている型。もし両方のメソッドが存在する場合は、<code>valueOf</code> が使用されます。ただし、その型が <code>enum</code> の場合は <code>fromString</code> が使用されます。</p>
</li>
<li>
<p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/List.html"><code>List&lt;T&gt;</code></a>、<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html"><code>Set&lt;T&gt;</code></a>、または <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/SortedSet.html"><code>SortedSet&lt;T&gt;</code></a>。ここで <code>T</code> は上記の基準を満たします。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>次の例は、これらすべての可能性を示しています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.util.List;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.ext.ParamConverter;
import javax.ws.rs.ext.ParamConverterProvider;
import javax.ws.rs.ext.Provider;

import org.jboss.resteasy.reactive.RestQuery;

@Provider
class MyConverterProvider implements ParamConverterProvider {

    @Override
    public &lt;T&gt; ParamConverter&lt;T&gt; getConverter(Class&lt;T&gt; rawType, Type genericType,
                                              Annotation[] annotations) {
        // declare a converter for this type
        if(rawType == Converter.class) {
            return (ParamConverter&lt;T&gt;) new MyConverter();
        }
        return null;
    }

}

// this is my custom converter
class MyConverter implements ParamConverter&lt;Converter&gt; {

    @Override
    public Converter fromString(String value) {
        return new Converter(value);
    }

    @Override
    public String toString(Converter value) {
        return value.value;
    }

}

// this uses a converter
class Converter {
    String value;
    Converter(String value) {
        this.value = value;
    }
}

class Constructor {
    String value;
    // this will use the constructor
    public Constructor(String value) {
        this.value = value;
    }
}

class ValueOf {
    String value;
    private ValueOf(String value) {
        this.value = value;
    }
    // this will use the valueOf method
    public static ValueOf valueOf(String value) {
        return new ValueOf(value);
    }
}

@Path("hello")
public class Endpoint {

    @Path("{converter}/{constructor}/{primitive}/{valueOf}")
    @GET
    public String conversions(Converter converter, Constructor constructor,
                              int primitive, ValueOf valueOf,
                              @RestQuery List&lt;Constructor&gt; list) {
        return converter + "/" + constructor + "/" + primitive
               + "/" + valueOf + "/" + list;
    }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="日付の取り扱い"><a class="anchor" href="#日付の取り扱い"></a>日付の取り扱い</h4>
<div class="paragraph">
<p>RESTEasy Reactive supports the use of the implementations of <code>java.time.Temporal</code> (like <code>java.time.LocalDateTime</code>) as query, path or form params. Furthermore, it provides the <code>@org.jboss.resteasy.reactive.DateFormat</code> annotation which can be used to set a custom expected pattern (otherwise the JDK&#8217;s default format for each type is used implicitly).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="前提条件"><a class="anchor" href="#前提条件"></a>前提条件</h3>
<div class="paragraph">
<p>以下のようないくつかの条件の下で、<a href="https://tools.ietf.org/html/rfc7232">HTTPでは条件付きのリクエストが可能です</a> :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>リソースの最終変更日</p>
</li>
<li>
<p>リソースの状態またはバージョンを指定するためのリソースのハッシュコードに似たリソースタグ</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1/javax/ws/rs/core/Request.html"><code>Request</code></a> コンテキストオブジェクトを使用して、条件付きリクエスト検証を行う方法を見てみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.time.temporal.TemporalUnit;
import java.util.Date;

import javax.ws.rs.GET;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.core.EntityTag;
import javax.ws.rs.core.Request;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.ResponseBuilder;

@Path("conditional")
public class Endpoint {

    // It's important to keep our date on seconds because that's how it's sent to the
    // user in the Last-Modified header
    private Date date = Date.from(Instant.now().truncatedTo(ChronoUnit.SECONDS));
    private int version = 1;
    private EntityTag tag = new EntityTag("v1");
    private String resource = "Some resource";

    @GET
    public Response get(Request request) {
        // first evaluate preconditions
        ResponseBuilder conditionalResponse = request.evaluatePreconditions(date, tag);
        if(conditionalResponse != null)
            return conditionalResponse.build();
        // preconditions are OK
        return Response.ok(resource)
                .lastModified(date)
                .tag(tag)
                .build();
    }

    @PUT
    public Response put(Request request, String body) {
        // first evaluate preconditions
        ResponseBuilder conditionalResponse = request.evaluatePreconditions(date, tag);
        if(conditionalResponse != null)
            return conditionalResponse.build();
        // preconditions are OK, we can update our resource
        resource = body;
        date = Date.from(Instant.now().truncatedTo(ChronoUnit.SECONDS));
        version++;
        tag = new EntityTag("v" + version);
        return Response.ok(resource)
                .lastModified(date)
                .tag(tag)
                .build();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>GET /conditional</code> を初めて呼び出すと、このようなレスポンスが返ってきます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">HTTP/1.1 200 OK
Content-Type: text/plain;charset=UTF-8
ETag: "v1"
Last-Modified: Wed, 09 Dec 2020 16:10:19 GMT
Content-Length: 13

Some resource</code></pre>
</div>
</div>
<div class="paragraph">
<p>これで、新しいバージョンを取得する必要があるかどうかを確認したい場合は、次のようなリクエストを行うことができます:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">GET /conditional HTTP/1.1
Host: localhost:8080
If-Modified-Since: Wed, 09 Dec 2020 16:10:19 GMT</code></pre>
</div>
</div>
<div class="paragraph">
<p>そして、次のようなレスポンスが返ってきます:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">HTTP/1.1 304 Not Modified</code></pre>
</div>
</div>
<div class="paragraph">
<p>なぜなら、そのリソースはその日以降に変更されていないからです。これはリソースを送信する手間を省くだけでなく、ユーザーが同時に変更されたことを検出するのにも役立ちます。たとえば、あるクライアントがリソースを更新したいが、別のユーザーがその後にリソースを変更したとしましょう。この場合、前の <code>GET</code> リクエストに続いて、この更新を行うことができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">PUT /conditional HTTP/1.1
Host: localhost:8080
If-Unmodified-Since: Wed, 09 Dec 2020 16:25:43 GMT
If-Match: v1
Content-Length: 8
Content-Type: text/plain

newstuff</code></pre>
</div>
</div>
<div class="paragraph">
<p>また、他のユーザーが GET と PUT の間のリソースを変更した場合は、次の回答が返されます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">HTTP/1.1 412 Precondition Failed
ETag: "v2"
Content-Length: 0</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ネゴシエーション"><a class="anchor" href="#ネゴシエーション"></a>ネゴシエーション</h3>
<div class="paragraph">
<p>One of the main ideas of REST (<a href="https://tools.ietf.org/html/rfc7231#section-3.4">and HTTP</a>) is that your resource is independent of its representation, and that both the client and server are free to represent their resources in as many media types as they want. This allows the server to declare support for multiple representations and let the client declare which ones it supports and get served something appropriate.</p>
</div>
<div class="paragraph">
<p>次のエンドポイントは、プレーンテキストまたは JSON での cheese の提供をサポートしています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

import com.fasterxml.jackson.annotation.JsonCreator;

class Cheese {
    public String name;
    @JsonCreator
    public Cheese(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "Cheese: " + name;
    }
}

@Path("negotiated")
public class Endpoint {

    @Produces({MediaType.APPLICATION_JSON, MediaType.TEXT_PLAIN})
    @GET
    public Cheese get() {
        return new Cheese("Morbier");
    }

    @Consumes(MediaType.TEXT_PLAIN)
    @PUT
    public Cheese putString(String cheese) {
        return new Cheese(cheese);
    }

    @Consumes(MediaType.APPLICATION_JSON)
    @PUT
    public Cheese putJson(Cheese cheese) {
        return cheese;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>JSON の場合、ユーザーは <a href="https://tools.ietf.org/html/rfc7231#section-5.3.2"><code>Accept</code></a> ヘッダーでどの表現を取得するかを選択することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">&gt; GET /negotiated HTTP/1.1
&gt; Host: localhost:8080
&gt; Accept: application/json

&lt; HTTP/1.1 200 OK
&lt; Content-Type: application/json
&lt; Content-Length: 18
&lt;
&lt; {"name":"Morbier"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>そしてテキストの場合:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">&gt; GET /negotiated HTTP/1.1
&gt; Host: localhost:8080
&gt; Accept: text/plain
&gt;
&lt; HTTP/1.1 200 OK
&lt; Content-Type: text/plain
&lt; Content-Length: 15
&lt;
&lt; Cheese: Morbier</code></pre>
</div>
</div>
<div class="paragraph">
<p>同様に、2 つの異なる表現を PUT することができます。JSON:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">&gt; PUT /negotiated HTTP/1.1
&gt; Host: localhost:8080
&gt; Content-Type: application/json
&gt; Content-Length: 16
&gt;
&gt; {"name": "brie"}

&lt; HTTP/1.1 200 OK
&lt; Content-Type: application/json;charset=UTF-8
&lt; Content-Length: 15
&lt;
&lt; {"name":"brie"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>またはプレーンテキスト:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">&gt; PUT /negotiated HTTP/1.1
&gt; Host: localhost:8080
&gt; Content-Type: text/plain
&gt; Content-Length: 9
&gt;
&gt; roquefort

&lt; HTTP/1.1 200 OK
&lt; Content-Type: application/json;charset=UTF-8
&lt; Content-Length: 20
&lt;
&lt; {"name":"roquefort"}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="http-圧縮"><a class="anchor" href="#http-圧縮"></a>HTTP 圧縮</h3>
<div class="paragraph">
<p>HTTP レスポンスのボディは、デフォルトでは圧縮されていません。<code>quarkus.http.enable-compression=true</code> を使用して HTTP 圧縮サポートを有効にできます。</p>
</div>
<div class="paragraph">
<p>圧縮サポートが有効であれば、以下の場合にレスポンスボディが圧縮されます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ルートメソッドが <code>@io.quarkus.vertx.http.Compressed</code> でアノテーションされている、または</p>
</li>
<li>
<p><code>Content-Type</code> ヘッダーが設定されており、その値は <code>quarkus.http.compress-media-types</code> を介して設定された圧縮メディアタイプである。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>次の場合、レスポンスボディは圧縮されません。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ルートメソッドが <code>@io.quarkus.vertx.http.Uncompressed</code> でアノテーションされている、または</p>
</li>
<li>
<p><code>Content-Type</code> ヘッダーが設定されていない。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
デフォルトでは、次のメディアタイプのリストが圧縮されています: <code>text/html</code>、<code>text/plain</code>、<code>text/xml</code>、<code>text/css</code>、<code>text/javascript</code>、<code>application/javascript</code>。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
クライアントが HTTP 圧縮をサポートしていない場合、レスポンスボディは圧縮されません。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ビルド時条件でjax-rsクラスを含める除外する"><a class="anchor" href="#ビルド時条件でjax-rsクラスを含める除外する"></a>ビルド時条件でJAX-RSクラスを含める/除外する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quarkusでは、CDI Beanの場合と同様に、ビルド時の条件に応じて、JAX-RSリソース、プロバイダー、および機能を直接包含または除外することができます。したがって、さまざまなJAX-RSクラスは、プロファイル条件（ <code>@io.quarkus.arc.profile.IfBuildProfile</code> または <code>@io.quarkus.arc.profile.UnlessBuildProfile</code> ）および／またはプロパティ条件（ <code>io.quarkus.arc.properties.IfBuildProperty</code> または <code>io.quarkus.arc.properties.UnlessBuildProperty</code> ）でアノテーションすることができ、構築時にどの条件でこれらのJAX-RSクラスが含まれるべきかをQuarkusに示すことができます。</p>
</div>
<div class="paragraph">
<p>次の例では、Quarkusは、ビルドプロファイル <code>app1</code> が有効になっている場合に限り、エンドポイント <code>sayHello</code> を含めます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@IfBuildProfile("app1")
public class ResourceForApp1Only {

    @GET
    @Path("sayHello")
    public String sayHello() {
        return "hello";
     }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>JAX-RSアプリケーションが検出され、メソッド <code>getClasses()</code> および／または <code>getSingletons()</code> がオーバーライドされている／されている場合、Quarkusはビルド時の条件を無視し、JAX-RSアプリケーションで定義されているもののみを考慮することに注意してください。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="resteasy-reactive-クライアント"><a class="anchor" href="#resteasy-reactive-クライアント"></a>RESTEasy Reactive クライアント</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RESTEasy Reactiveには、サーバー側に加えて、ノンブロッキングを核とした新しいMicroProfile Rest Clientの実装が搭載されています。</p>
</div>
<div class="paragraph">
<p>なお、RESTEasy Reactiveでは、 <code>quarkus-rest-client</code> エクステンションが正常に動作しない場合があります。 <code>quarkus-rest-client-reactive</code> を代わりに使用して下さい。</p>
</div>
<div class="paragraph">
<p>リアクティブ・クライアントの詳細については、<a href="rest-client-reactive.html">REST Client Reactiveガイド</a> を参照してください。</p>
</div>
</div>
</div>
    </div>
  </div>
</div>

  </div>

  <div class="content project-footer">
  <div class="footer-section">
    <div class="logo-wrapper">
      <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_reverse.svg" class="project-logo" title="Quarkus"></a>
    </div>
  </div>
  <div class="grid-wrapper">
    <p class="grid__item width-3-12">Quarkus はオープンです。このプロジェクトの全ての依存関係は<a href='https://www.apache.org/licenses/LICENSE-2.0' target='_blank'>Apache Software License 2.0</a>または互換性のあるライセンスの元で利用出来ます。<br /><br />このウェブサイトは <a href='https://jekyllrb.com/' target='_blank'>Jekyll</a> で構築されており、<a href='https://pages.github.com/' target='_blank'>Github Pages</a>にホストされており、完全にオープンソースです。改善したい場合、 <a href='https://github.com/quarkusio/quarkusio.github.io' target='_blank'>ウェブサイトをフォークし</a>、修正してみせてください。</p>

    
      <div class="width-1-12 project-links">
        <span>ナビゲーション</span>
        <ul class="footer-links">
          
            <li><a href="/">ホーム</a></li>
          
            <li><a href="/about">Quarkusについて</a></li>
          
            <li><a href="/blog">ブログ</a></li>
          
            <li><a href="/insights">ポッドキャスト</a></li>
          
            <li><a href="/events">イベント</a></li>
          
            <li><a href="/newsletter">ニュースレター</a></li>
          
            <li><a href="/publications">出版</a></li>
          
            <li><a href="/awards">受賞</a></li>
          
            <li><a href="/security">セキュリティポリシー</a></li>
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>フォロー</span>
        <ul class="footer-links">
          
            <li><a href="https://twitter.com/quarkusio">Twitter</a></li>
          
            <li><a href="https://www.facebook.com/quarkusio">Facebook</a></li>
          
            <li><a href="https://www.linkedin.com/company/quarkusio/">Linkedin</a></li>
          
            <li><a href="https://www.youtube.com/channel/UCaW8QG_QoIk_FnjLgr5eOqg">Youtube</a></li>
          
            <li><a href="https://github.com/quarkusio">GitHub</a></li>
          
        </ul>
      </div>
    
      <div class="width-2-12 project-links">
        <span>ヘルプ</span>
        <ul class="footer-links">
          
            <li><a href="/support">サポート</a></li>
          
            <li><a href="/guides">ガイド</a></li>
          
            <li><a href="/faq">FAQ</a></li>
          
            <li><a href="/get-started">入門</a></li>
          
            <li><a href="https://stackoverflow.com/questions/tagged/quarkus">Stack Overflow</a></li>
          
            <li><a href="https://github.com/quarkusio/quarkus/discussions">ディスカッション</a></li>
          
            <li><a href="https://groups.google.com/forum/#!forum/quarkus-dev">開発メーリングリスト</a></li>
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>言語</span>
        <ul class="footer-links">
          
            <li><a href="https://quarkus.io/">English</a></li>
          
            <li><a href="https://es.quarkus.io/">Español</a></li>
          
            <li><a href="https://cn.quarkus.io/">简体中文</a></li>
          
            <li><a href="https://ja.quarkus.io/">日本語</a></li>
          
        </ul>
      </div>
    

    
      <div class="width-4-12 more-links">
        <span>Quarkusはコミュニティプロジェクトで構成されています：</span>
        <ul class="footer-links">
          
            <li><a href="https://vertx.io/" target="_blank">Eclipse Vert.x</a></li>
          
            <li><a href="https://smallrye.io" target="_blank">SmallRye</a></li>
          
            <li><a href="https://hibernate.org" target="_blank">Hibernate</a></li>
          
            <li><a href="https://netty.io" target="_blank">Netty</a></li>
          
            <li><a href="https://resteasy.github.io" target="_blank">RESTEasy</a></li>
          
            <li><a href="https://camel.apache.org" target="_blank">Apache Camel</a></li>
          
            <li><a href="https://microprofile.io" target="_blank">Eclipse MicroProfile</a></li>
          
            <li><a href="https://code.quarkus.io/" target="_blank">等々...</a></li>
          
        </ul>
      </div>
    
  </div>
</div>

  <div class="content redhat-footer">
  <div class="grid-wrapper">
    <span class="licence">
      <i class="fab fa-creative-commons"></i><i class="fab fa-creative-commons-by"></i> <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">CC by 3.0</a> | <a href="https://www.redhat.com/en/about/privacy-policy">Privacy Policy</a>
    </span>
    <span class="redhat">
      Sponsored by
    </span>
    <span class="redhat-logo">
      <a href="https://www.redhat.com/" target="_blank"><img src="/assets/images/redhat_reversed.svg"></a>
    </span>
  </div>
</div>


  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>
  <script type="text/javascript" src="/assets/javascript/mobile-nav.js"></script>
  <script type="text/javascript" src="/assets/javascript/scroll-down.js"></script>
  <script src="/assets/javascript/satellite.js" type="text/javascript"></script>
  <script src="/guides/javascript/config.js" type="text/javascript"></script>
  <script src="/assets/javascript/search-filter.js" type="text/javascript"></script>
  <script src="/assets/javascript/guides-version-dropdown.js" type="text/javascript"></script>
  <script src="/assets/javascript/back-to-top.js" type="text/javascript"></script>
  <script src="/assets/javascript/clipboard.min.js" type="text/javascript"></script>
  <script src="/assets/javascript/copy.js" type="text/javascript"></script>
  <script src="/assets/javascript/asciidoc-tabs.js" type="text/javascript"></script>
</body>

</html>
